<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (IMG) - Chapter 3: Sphere groups and machines</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap3"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4.html">[Next Chapter]</a>&nbsp;  </div>

<p><a id="X87E6D4907EF8DC8F" name="X87E6D4907EF8DC8F"></a></p>
<div class="ChapSects"><a href="chap3.html#X87E6D4907EF8DC8F">3 <span class="Heading">Sphere groups and machines</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7BEB8F477B8569B4">3.1 <span class="Heading">Sphere groups</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X834FE6AC798A520F">3.1-1 IsSphereGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X87E99FEC8598B845">3.1-2 IsomorphismSphereGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8307F8DB85F145AE">3.1-3 EulerCharacteristic</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X81B9BA1586981067">3.1-4 RankOfSphereGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X79A08D5C8532F976">3.1-5 OrderingOfSphereGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7D973ED3816A1CBD">3.1-6 ExponentsOfSphereGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7ECF53F97DC06E4C">3.1-7 IsomorphismFreeGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7DBBD32080770BD7">3.1-8 SphereGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8120094A7BFA9C48">3.1-9 IsSphereConjugacyClass</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8123456781234567">3.1-10 </a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X867DE11A7E9E02E7">3.1-11 PeripheralClasses</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X822BA8867B084B6C">3.1-12 IntersectionNumber</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X87677B0787B4461A">3.1-13 AutomorphismGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7A205FFD86D128B9">3.1-14 AmalgamateFreeProduct</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7AF2D874807E68BB">3.2 <span class="Heading">Sphere machines</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7A327CA47E574383">3.2-1 IsSphereMachine</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X86CAE06C7EBAFB00">3.2-2 AsSphereMachine</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X81BA485A7B053B80">3.2-3 CleanedSphereMachine</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B17531E7B058369">3.2-4 NewSphereMachine</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X8231595E8113D281">3.3 <span class="Heading">Polynomial sphere machines</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X80E689F38412EE20">3.3-1 PolynomialSphereMachine</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X814E27317A6213D3">3.3-2 SupportingRays</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7EE9C721802D481B">3.3-3 NormalizedPolynomialSphereMachine</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X81B7D47D81212C4F">3.3-4 SimplifiedSphereMachine</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7AB029AE8590964E">3.3-5 Mating</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X84C2881D87C1FB74">3.3-6 IsKneadingMachine</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X82F34D5387FF4E57">3.3-7 AddingElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7BE171B879357604">3.3-8 AsPolynomialSphereMachine</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8692875A793FB66F">3.3-9 LiftOfConjugacyClass</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7BE001A0811CD599">3.3-10 ComplexConjugate</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7E941D2185A1DF3B">3.3-11 RotatedSpider</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X86C9E1938159FEE1">3.3-12 KneadingSequence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X857FCD7678B12A0C">3.3-13 AllInternalAddresses</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X86C250907E09F399">3.3-14 ExternalAnglesRelation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X84F962AF7D553DDA">3.3-15 ExternalAngle</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7C2EE46F7CFC2CD3">3.4 <span class="Heading">Automorphisms of sphere machines</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8410869F8358A1AF">3.4-1 AutomorphismVirtualEndomorphism</a></span>
</div></div>
</div>

<h3>3 <span class="Heading">Sphere groups and machines</span></h3>

<p><a id="X7BEB8F477B8569B4" name="X7BEB8F477B8569B4"></a></p>

<h4>3.1 <span class="Heading">Sphere groups</span></h4>

<p>Fundamental groups of punctured spheres, and of sphere orbifolds, are defined in <strong class="pkg">IMG</strong> as a special class of finitely presented groups. The generators of the group represent the punctures of the sphere, or more generally its orbispace points. DeclareProperty("IsSphereGroup", IsFpGroup); DeclareCategory("IsElementOfSphereGroup", IsElementOfFpGroup and IsAssocWord); DeclareCategoryCollections("IsElementOfSphereGroup"); DeclareCategoryCollections("IsElementOfSphereGroupCollection"); DeclareProperty("IsElementOfSphereGroupFamily", IsElementOfFpGroupFamily); DeclareOperation("ElementOfSphereGroup", [IsFamily, IsAssocWordWithInverse]);</p>

<p><a id="X834FE6AC798A520F" name="X834FE6AC798A520F"></a></p>

<h5>3.1-1 IsSphereGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSphereGroup</code></td><td class="tdright">( filter )</td></tr></table></div>
<p>A sphere group is a special kind of finitely presented group, in which exactly one relation is a product, in some order, of all the generators, and all the other relations (possibly none) are powers of generators.</p>

<p>Sphere groups are used to represent the fundamental groups of punctured spheres, or more generally orbifolds whose underlying space is a sphere.</p>

<p>DeclareAttribute("IsomorphismSphereGroup", IsFpGroup); DeclareAttribute("AsSphereGroup", IsFpGroup);</p>

<p><a id="X87E99FEC8598B845" name="X87E99FEC8598B845"></a></p>

<h5>3.1-2 IsomorphismSphereGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismSphereGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsSphereGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>These functions compute an isomorphism from <var class="Arg">g</var> to a sphere group; the first form returns the isomorphism, while the second one returns its image.</p>

<p>DeclareAttribute("EulerCharacteristic", IsGroup);</p>

<p><a id="X8307F8DB85F145AE" name="X8307F8DB85F145AE"></a></p>

<h5>3.1-3 EulerCharacteristic</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EulerCharacteristic</code>( <var class="Arg">g</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The Euler characteristic of <var class="Arg">g</var>.</p>

<p>The Euler characteristic of a free group of rank <span class="SimpleMath">n</span> is <span class="SimpleMath">1-n</span>; and it multiplies by the index on subgroups. A sphere group is finite if and only if its Euler characteristic is positive, and is virtually abelian if and only if its Euler characteristic is <span class="SimpleMath">0</span>.</p>

<p>DeclareAttribute("RankOfSphereGroup", IsSphereGroup);</p>

<p><a id="X81B9BA1586981067" name="X81B9BA1586981067"></a></p>

<h5>3.1-4 RankOfSphereGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RankOfSphereGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The number of generators of <var class="Arg">g</var>.</p>

<p>DeclareAttribute("OrderingOfSphereGroup", IsSphereGroup);</p>

<p><a id="X79A08D5C8532F976" name="X79A08D5C8532F976"></a></p>

<h5>3.1-5 OrderingOfSphereGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OrderingOfSphereGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The list of the orders of the generators.</p>

<p>This attribute has the property that <code class="code">Product(GeneratorsOfGroup(g){OrderingOfSphereGroup(g)})</code> is the identity.</p>

<p>DeclareAttribute("ExponentsOfSphereGroup", IsSphereGroup);</p>

<p><a id="X7D973ED3816A1CBD" name="X7D973ED3816A1CBD"></a></p>

<h5>3.1-6 ExponentsOfSphereGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExponentsOfSphereGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The list of exponents of the generators.</p>

<p>This attribute has the property that <code class="code">GeneratorsOfGroup(g)[i]^ExponentsOfSphereGroup(g)[i]</code> is the identity for all <code class="code">i</code>. If an element has infinite order, the value stored is <code class="code">0</code>.</p>

<p>DeclareAttribute("IsomorphismFreeGroup", IsSphereGroup);</p>

<p><a id="X7ECF53F97DC06E4C" name="X7ECF53F97DC06E4C"></a></p>

<h5>3.1-7 IsomorphismFreeGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismFreeGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: An isomorphism to a free group, if it exists.</p>

<p>If <var class="Arg">g</var> was created as a sphere group with all exponents infinity, then <var class="Arg">g</var> is isomorphic to a free group on all the generators but one; this attribute stores such an isomorphism.</p>

<p>DeclareGlobalFunction("SphereGroup");</p>

<p><a id="X7DBBD32080770BD7" name="X7DBBD32080770BD7"></a></p>

<h5>3.1-8 SphereGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SphereGroup</code>( <var class="Arg">ordering</var>[, <var class="Arg">exponent</var>] )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: A new sphere group.</p>

<p><var class="Arg">ordering</var> is either a list of integers, describing the order of the generators that is to be trivial; or an integer <code class="code">m</code>, in which case the ordering is <code class="code">[m,m-1,..,1]</code>.</p>

<p>The optional second argument <var class="Arg">exponent</var> is a list of integers describing the exponents of the generators. The value <code class="code">0</code> specifies a generator of infinite order.</p>

<p>DeclareProperty("IsSphereConjugacyClass", IsAssociativeElementCollection and IsMultiplicativeElementWithInverseCollection); DeclareProperty("IsSphereConjugacyClassCollection", IsAssociativeElementCollColl and IsMultiplicativeElementWithInverseCollColl); DeclareSynonym("IsMulticurve", IsSphereConjugacyClassCollection); DeclareOperation("InverseMutable", [IsSphereConjugacyClass]); DeclareOperation("InverseSameMutability", [IsSphereConjugacyClass]); DeclareAttribute("InverseImmutable", IsSphereConjugacyClass); DeclareOperation("POW", [IsSphereConjugacyClass,IsInt]);</p>

<p><a id="X8120094A7BFA9C48" name="X8120094A7BFA9C48"></a></p>

<h5>3.1-9 IsSphereConjugacyClass</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSphereConjugacyClass</code></td><td class="tdright">( filter )</td></tr></table></div>
<p>Elements of a sphere group represent based loops on a punctured sphere. Loops (without specified basepoint) are represented by conjugacy classes. A <em>multicurve</em> is a collection of non-intersecting loops.</p>

<p>Conjugacy classes may be raised to integer powers; the <span class="SimpleMath">n</span>th power of a conjugacy class is the conjugacy class of the <span class="SimpleMath">n</span>th power of an element.</p>

<p>DeclareProperty("IsPeripheral", IsElementOfSphereGroup); DeclareProperty("IsPeripheral", IsSphereConjugacyClass);</p>

<p><a id="X8123456781234567" name="X8123456781234567"></a></p>

<h5>3.1-10 </h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; </code>( <var class="Arg">c</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>Returns: Whether the conjugacy class <var class="Arg">c</var> is peripheral.</p>

<p>A conjugacy class is <em>peripheral</em> if it contains a generator of the sphere group.</p>

<p>DeclareAttribute("PeripheralClasses", IsSphereGroup);</p>

<p><a id="X867DE11A7E9E02E7" name="X867DE11A7E9E02E7"></a></p>

<h5>3.1-11 PeripheralClasses</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PeripheralClasses</code>( <var class="Arg">g</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The peripheral conjugacy classes of <var class="Arg">g</var>.</p>

<p>DeclareOperation("IntersectionNumber", [IsSphereConjugacyClass,IsSphereConjugacyClass]); DeclareOperation("SelfIntersectionNumber", [IsSphereConjugacyClass]);</p>

<p><a id="X822BA8867B084B6C" name="X822BA8867B084B6C"></a></p>

<h5>3.1-12 IntersectionNumber</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IntersectionNumber</code>( <var class="Arg">c</var>, <var class="Arg">d</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The intersection number of the conjugacy classes <var class="Arg">c</var> and <var class="Arg">d</var>.</p>

<p>The <em>geometric intersection number</em> of two loops is the minimal number of intersections they may have. The <em>self-intersection number</em> of a loop is the intersection number of the loop with a small translate.</p>

<p>DeclareProperty("IsAutomorphismGroupOfSphereGroup", IsAutomorphismGroup); InstallTrueMethod(IsAutomorphismGroup, IsAutomorphismGroupOfSphereGroup); DeclareAttribute("EpimorphismToOut", IsAutomorphismGroupOfSphereGroup);</p>

<p><a id="X87677B0787B4461A" name="X87677B0787B4461A"></a></p>

<h5>3.1-13 AutomorphismGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AutomorphismGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EpimorphismToOut</code>( <var class="Arg">a</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>This function computes the <em>pure</em> automorphism group of the sphere group <var class="Arg">g</var>, namely the group of automorphisms that preserves all the peripheral conjugacy classes (conjugacy classes of generators).</p>

<p>The attribute <code class="code">EpimorphismToOut</code> stores an epimorphism from the automorphism group to the group of outer automorphisms.</p>

<p>DeclareOperation("AmalgamatedFreeProduct", [IsSphereGroup,IsSphereGroup,IsElementOfSphereGroup,IsElementOfSphereGroup]); DeclareAttribute("EmbeddingsOfAmalgamatedFreeProduct", IsSphereGroup);</p>

<p><a id="X7A205FFD86D128B9" name="X7A205FFD86D128B9"></a></p>

<h5>3.1-14 AmalgamateFreeProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AmalgamateFreeProduct</code>( <var class="Arg">g</var>, <var class="Arg">h</var>, <var class="Arg">x</var>, <var class="Arg">y</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>This function computes the amalgamated free product of two sphere groups <var class="Arg">g</var> and <var class="Arg">h</var>, along the cyclic subgroups <span class="SimpleMath">⟨ x⟩</span> of <var class="Arg">g</var> and <span class="SimpleMath">⟨ y⟩</span> of <var class="Arg">h</var>.</p>

<p>The attribute <code class="code">EmbeddingsOfAmalgamatedFreeProduct</code> is a list of length two, storing the embeddings of <var class="Arg">g</var> and <var class="Arg">h</var> respectively into the amalgam.</p>

<p><a id="X7AF2D874807E68BB" name="X7AF2D874807E68BB"></a></p>

<h4>3.2 <span class="Heading">Sphere machines</span></h4>

<p>Sphere machines are simply group FR machines (see Section <a href="/Users/laurent/.gap/pkg/fr/doc/chap3.html#X80D310EF7FD5EA44"><span class="RefLink">FR: FRMachineNC (family,free,listlist,list)</span></a>) whose underlying <code class="func">StateSet</code> (<a href="/Users/laurent/.gap/pkg/fr/doc/chap3.html#X8000470D7DA7FFBD"><span class="RefLink">FR: StateSet (FR machine)</span></a>) is a sphere group. DeclareProperty("IsSphereMachine", IsFRMachine);</p>

<p><a id="X7A327CA47E574383" name="X7A327CA47E574383"></a></p>

<h5>3.2-1 IsSphereMachine</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSphereMachine</code>( <var class="Arg">m</var> )</td><td class="tdright">( filter )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPolynomialSphereMachine</code>( <var class="Arg">m</var> )</td><td class="tdright">( filter )</td></tr></table></div>
<p>The categories of <em>Sphere</em> and <em>polynomial</em> machines. Sphere machines are group FR machines whose underlying group is a sphere group, see <code class="func">SphereGroup</code> (<a href="chap3.html#X7DBBD32080770BD7"><span class="RefLink">3.1-8</span></a>).</p>

<p>A polynomial machine is a group FR machine with a distinguished state (which must be a generator of the stateset), stored as the attribute <code class="func">AddingElement</code> (<a href="chap3.html#X82F34D5387FF4E57"><span class="RefLink">3.3-7</span></a>); see <code class="func">AsPolynomialSphereMachine</code> (<a href="chap3.html#X7BE171B879357604"><span class="RefLink">3.3-8</span></a>). If it is normalized, in the sense that the wreath recursion of the adding element <code class="code">a</code> is <code class="code">[[a,1,...,1],[d,1,...,d-1]]</code>, then the basepoint is assumed to be at <span class="SimpleMath">+∞</span>; the element <code class="code">a</code> describes a clockwise loop around infinity; the <span class="SimpleMath">k</span>th preimage of the basepoint is at <span class="SimpleMath">exp(2iπ(k-1)/d)∞</span>, for <span class="SimpleMath">k=1,dots,d</span>; and there is a direct connection from basepoint <span class="SimpleMath">k</span> to <span class="SimpleMath">k+1</span> for all <span class="SimpleMath">k=1,dots,d-1</span>.</p>

<p>The last category is the intersection of the first two.</p>

<p>DeclareAttribute("AsSphereMachine", IsFRMachine); DeclareOperation("AsSphereMachine", [IsFRMachine, IsWord]); DeclareOperation("AsSphereMachine", [IsFRMachine, IsSphereGroup]);</p>

<p><a id="X86CAE06C7EBAFB00" name="X86CAE06C7EBAFB00"></a></p>

<h5>3.2-2 AsSphereMachine</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsSphereMachine</code>( <var class="Arg">m</var>[, <var class="Arg">w</var>] )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A sphere machine.</p>

<p>This function creates a new sphere machine, starting from a group FR machine <var class="Arg">m</var>. If a state <var class="Arg">w</var> is specified, and that state defines the trivial FR element, then it is used as relator; if <var class="Arg">w</var> is a sphere group, then it is used as the new stateset. Finally, if no relator and no group is specified, and the product (in some ordering) of the generators is trivial, then that product is used as relator. In other cases, the method returns <code class="keyw">fail</code>.</p>

<p>A standard FR machine can be recovered from a sphere machine by <code class="func">AsGroupFRMachine</code> (<a href="/Users/laurent/.gap/pkg/fr/doc/chap3.html#X7BF186227C0ABE8D"><span class="RefLink">FR: AsGroupFRMachine</span></a>), <code class="func">AsMonoidFRMachine</code> (<a href="/Users/laurent/.gap/pkg/fr/doc/chap3.html#X7BF186227C0ABE8D"><span class="RefLink">FR: AsMonoidFRMachine</span></a>), and <code class="func">AsSemigroupFRMachine</code> (<a href="/Users/laurent/.gap/pkg/fr/doc/chap3.html#X7BF186227C0ABE8D"><span class="RefLink">FR: AsSemigroupFRMachine</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := UnderlyingFRMachine(BasilicaGroup);</span>
&lt;Mealy machine on alphabet [ 1 .. 2 ] with 3 states&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := AsGroupFRMachine(m);</span>
&lt;FR machine with alphabet [ 1 .. 2 ] on Group( [ f1, f2 ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsSphereMachine(g,Product(GeneratorsOfFRMachine(g)));</span>
&lt;FR machine with alphabet [ 1 .. 2 ] on Group( [ f1, f2, t ] )/[ f1*f2*t ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(last);</span>
 G  |              1         2
----+-----------------+---------+
 f1 |          &lt;id&gt;,2      f2,1
 f2 |          &lt;id&gt;,1      f1,2
  t | f2^-1*f1*f2*t,2   f1^-1,1
----+-----------------+---------+
Relator: f1*f2*t
</pre></div>

<p>DeclareAttribute("CleanedSphereMachine",IsSphereMachine);</p>

<p><a id="X81BA485A7B053B80" name="X81BA485A7B053B80"></a></p>

<h5>3.2-3 CleanedSphereMachine</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CleanedSphereMachine</code>( <var class="Arg">m</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: A cleaned-up version of <var class="Arg">m</var>.</p>

<p>This command attempts to shorten the length of the transitions in <var class="Arg">m</var>, and ensure (if possible) that the product along every cycle of the states of a generator is a conjugate of a generator. It returns the new machine.</p>

<p>DeclareGlobalFunction("NewSphereMachine");</p>

<p><a id="X7B17531E7B058369" name="X7B17531E7B058369"></a></p>

<h5>3.2-4 NewSphereMachine</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NewSphereMachine</code>( <var class="Arg">...</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: A new sphere machine, based on string descriptions.</p>

<p>This command constructs a new sphere machine, in a format similar to <code class="func">FRGroup</code> (<a href="/Users/laurent/.gap/pkg/fr/doc/chap7.html#X7AE8F92383272329"><span class="RefLink">FR: FRGroup</span></a>); namely, the arguments are strings of the form "gen=&lt;word-1,...,word-d&gt;perm"; each <code class="code">word-i</code> is a word in the generators; and <code class="code">perm</code> is a transformation, either written in disjoint cycle or in images notation. The underlying group of the machine is a sphere group.</p>

<p><code class="code">word-i</code> is allowed to be the empty string; and the "&lt;...&gt;" may be skipped altogether. Each <code class="code">word-i</code> may also contain inverses.</p>

<p>The extra final arguments describe relations in the underlying sphere group; at least one relation is required, the product of the generators in an appropriate order.</p>

<p>The following examples construct realizable foldings of the polynomial <span class="SimpleMath">z^3+i</span>, following Cui's arguments.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fold1 := NewSphereMachine("a=&lt;,,b,,,B&gt;(1,2,3)(4,5,6)","b=&lt;,,b*a/b,,,B*A/B&gt;",</span>
     "A=&lt;,,b*a,,,B*A&gt;(3,6)","B=(1,6,5,4,3,2)","a*B*A*b");
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">&lt;FR machine with alphabet [ 1, 2, 3, 4, 5, 6 ] on Group( [ a, b, A, B ] )/[ a*B*A*b ]&gt;                                </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fold2 := NewSphereMachine("a=&lt;,,b,,,B&gt;(1,2,3)(4,5,6)","b=&lt;,,b*a/b,,,B*A/B&gt;",</span>
     "A=(1,6)(2,5)(3,4)","B=&lt;B*A,,,b*a,,&gt;(1,4)(2,6)(3,5)","a*B*A*b");;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RationalFunction(fold1); RationalFunction(fold2);</span>
...
</pre></div>

<p><a id="X8231595E8113D281" name="X8231595E8113D281"></a></p>

<h4>3.3 <span class="Heading">Polynomial sphere machines</span></h4>

<p>Polynomial sphere machines have a special extra attribute, an <code class="func">AddingElement</code> (<a href="chap3.html#X82F34D5387FF4E57"><span class="RefLink">3.3-7</span></a>). This is an element of the underlying FR group, which acts as an adding element on the machine's alphabet. It represents a fixed point of a Thurston map of maximal ramification; typically, the point <span class="SimpleMath">∞</span> of a polynomial. DeclareOperation("PolynomialMealyMachine",[IsPosInt,IsList,IsList]); DeclareOperation("PolynomialMealyMachine",[IsPosInt,IsList]); DeclareOperation("PolynomialSphereMachine",[IsPosInt,IsList,IsList,IsRecord]); DeclareOperation("PolynomialSphereMachine",[IsPosInt,IsList,IsList]); DeclareOperation("PolynomialSphereMachine",[IsPosInt,IsList,IsRecord]); DeclareOperation("PolynomialSphereMachine",[IsPosInt,IsList]);</p>

<p><a id="X80E689F38412EE20" name="X80E689F38412EE20"></a></p>

<h5>3.3-1 PolynomialSphereMachine</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolynomialSphereMachine</code>( <var class="Arg">d</var>, <var class="Arg">per</var>[, <var class="Arg">pre</var>] )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolynomialMealyMachine</code>( <var class="Arg">d</var>, <var class="Arg">per</var>[, <var class="Arg">pre</var>] )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A sphere or Mealy machine.</p>

<p>This function creates a sphere or Mealy machine that describes a topological polynomial. The polynomial is described symbolically in the language of <em>external angles</em>. For more details, see <a href="chapBib.html#biBMR762431">[DH84]</a> and <a href="chapBib.html#biBMR812271">[DH85]</a> (in the quadratic case), <a href="chapBib.html#biBMR1149891">[BFH92]</a> (in the preperiodic case), and <a href="chapBib.html#biBmath.DS/9305207">[Poi]</a> (in the general case).</p>

<p><var class="Arg">d</var> is the degree of the polynomial. <var class="Arg">per</var> and <var class="Arg">pre</var> are lists of angles or preangles. In what follows, angles are rational numbers, considered modulo 1. Each entry in <var class="Arg">per</var> or <var class="Arg">pre</var> is either a rational (interpreted as an angle), or a list of angles <span class="SimpleMath">[a_1,...,a_i]</span> such that <span class="SimpleMath">da_1=...=da_i</span>. The angles in <var class="Arg">per</var> are angles landing at the root of a Fatou component, and the angles in <var class="Arg">pre</var> land on the Julia set.</p>

<p>Note that, for sphere machines, the last generator of the machine produced is an adding machine, representing a loop going counterclockwise around infinity (in the compactification of <span class="SimpleMath">C</span> by a disk, this loop goes <em>clockwise</em> around that disk).</p>

<p>In constructing a polynomial sphere machine, one may specify a boolean flag <var class="Arg">formal</var>, which defaults to <code class="keyw">true</code>. In a <em>formal</em> recursion, distinct angles give distinct generators; while in a non-formal recursion, distinct angles, which land at the same point in the Julia set, give a single generator. The simplest example where this occurs is angle <span class="SimpleMath">5/12</span> in the quadratic family, in which angles <span class="SimpleMath">1/3</span> and <span class="SimpleMath">2/3</span> land at the same point -- see the example below.</p>

<p>The attribute <code class="code">Correspondence(m)</code> records the angles landing on the generators: <code class="code">Correspondence(m)[i]</code> is a list <code class="code">[a,s]</code> where <span class="SimpleMath">a</span> is an angle landing on generator <code class="code">i</code> and <span class="SimpleMath">s</span> is <code class="keyw">"Julia"</code> or <code class="keyw">"Fatou"</code>.</p>

<p>If only one list of angles is supplied, then <strong class="pkg">IMG</strong> guesses that all angles with denominator coprime to <var class="Arg">n</var> are Fatou, and all the others are Julia.</p>

<p>The inverse operation, reconstructing the angles from the sphere machine, is <code class="func">SupportingRays</code> (<a href="chap3.html#X814E27317A6213D3"><span class="RefLink">3.3-2</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolynomialSphereMachine(2,[0],[]); # the adding machine</span>
&lt;FR machine with alphabet [ 1 .. 2 ] on Group( [ f1, f2 ] )/[ f2*f1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(last);</span>
 G  |     1        2
----+--------+--------+
 f1 | &lt;id&gt;,2     f1,1
 f2 |   f2,2   &lt;id&gt;,1
----+--------+--------+
Relator: f2*f1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(PolynomialSphereMachine(2,[1/3],[])); # the Basilica</span>
 G  |      1         2
----+---------+---------+
 f1 | f1^-1,2   f2*f1,1
 f2 |    f1,1    &lt;id&gt;,2
 f3 |    f3,2    &lt;id&gt;,1
----+---------+---------+
Relator: f3*f2*f1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(PolynomialSphereMachine(2,[],[1/6])); # z^2+I</span>
 G  |            1         2
----+---------------+---------+
 f1 | f1^-1*f2^-1,2   f2*f1,1
 f2 |          f1,1      f3,2
 f3 |          f2,1    &lt;id&gt;,2
 f4 |          f4,2    &lt;id&gt;,1
----+---------------+---------+
Relator: f4*f3*f2*f1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolynomialSphereMachine(2,[],[5/12]);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolynomialSphereMachine(2,[],[5/12]);</span>
&lt;FR machine with alphabet [ 1, 2 ] and adder f5 on Group( [ f1, f2, f3, f4, f5 ] )/[ f5*f4*f3*f2*f1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Correspondence(last);</span>
[ [ 1/3, "Julia" ], [ 5/12, "Julia" ], [ 2/3, "Julia" ], [ 5/6, "Julia" ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolynomialSphereMachine(2,[],[5/12],false);</span>
&lt;FR machine with alphabet [ 1, 2 ] and adder f4 on Group( [ f1, f2, f3, f4 ] )/[ f4*f3*f2*f1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Correspondence(last);</span>
[ [ [ 1/3, 2/3 ], "Julia" ], [ [ 5/12 ], "Julia" ], [ [ 5/6 ], "Julia" ] ]
</pre></div>

<p>The following construct the examples in Poirier's paper:</p>


<div class="example"><pre>
PoirierExamples := function(arg)
    if arg=[1] then
        return PolynomialSphereMachine(2,[1/7],[]);
    elif arg=[2] then
        return PolynomialSphereMachine(2,[],[1/2]);
    elif arg=[3,1] then
        return PolynomialSphereMachine(2,[],[5/12]);
    elif arg=[3,2] then
        return PolynomialSphereMachine(2,[],[7/12]);
    elif arg=[4,1] then
        return PolynomialSphereMachine(3,[[3/4,1/12],[1/4,7/12]],[]);
    elif arg=[4,2] then
        return PolynomialSphereMachine(3,[[7/8,5/24],[5/8,7/24]],[]);
    elif arg=[4,3] then
        return PolynomialSphereMachine(3,[[1/8,19/24],[3/8,17/24]],[]);
    elif arg=[5] then
        return PolynomialSphereMachine(3,[[3/4,1/12],[3/8,17/24]],[]);
    elif arg=[6,1] then
        return PolynomialSphereMachine(4,[],[[1/4,3/4],[1/16,13/16],[5/16,9/16]]);
    elif arg=[6,2] then
        return PolynomialSphereMachine(4,[],[[1/4,3/4],[3/16,15/16],[7/16,11/16]]);
    elif arg=[7] then
        return PolynomialSphereMachine(5,[[0,4/5],[1/5,2/5,3/5]],[[1/5,4/5]]);
    elif arg=[9,1] then
        return PolynomialSphereMachine(3,[[0,1/3],[5/9,8/9]],[]);
    elif arg=[9,2] then
        return PolynomialSphereMachine(3,[[0,1/3]],[[5/9,8/9]]);
    else
        Error("Unknown Poirier example ",arg);
    fi;
end;
</pre></div>

<p>DeclareAttribute("SupportingRays",IsFRMachine);</p>

<p><a id="X814E27317A6213D3" name="X814E27317A6213D3"></a></p>

<h5>3.3-2 SupportingRays</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SupportingRays</code>( <var class="Arg">m</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: A <code class="code">[degree,fatou,julia]</code> description of <var class="Arg">m</var>.</p>

<p>This operation is the inverse of <code class="func">PolynomialSphereMachine</code> (<a href="chap3.html#X80E689F38412EE20"><span class="RefLink">3.3-1</span></a>): it computes a choice of angles, describing landing rays on Fatou/Julia critical points.</p>

<p>If there does not exist a complex realization, namely if the machine is obstructed, then this command returns an obstruction, as a record. The field <code class="keyw">minimal</code> is set to false, and a proper sub-machine is set as the field <code class="keyw">submachine</code>. The field <code class="keyw">homomorphism</code> gives an embedding of the stateset of <code class="keyw">submachine</code> into the original machine, and <code class="keyw">relation</code> is the equivalence relation on the set of generators of <var class="Arg">m</var> that describes the pinching.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r := PolynomialSphereMachine(2,[1/7],[]);</span>
&lt;FR machine with alphabet [ 1, 2 ] and adder f4 on Group( [ f1, f2, f3, f4 ] )/[ f4*f3*f2*f1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := StateSet(r);; SetName(F,"F");</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SupportingRays(r);</span>
[ 2, [ [ 1/7, 9/14 ] ], [  ] ] # actually returns the angle 2/7
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># now CallFuncList(PolynomialSphereMachine,last) would return the machine r</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">twist := GroupHomomorphismByImages(F,F,GeneratorsOfGroup(F),[F.1^(F.2*F.1),F.2^F.1,F.3,F.4])^-1;</span>
[ f1, f2, f3, f4 ] -&gt; [ f1*f2*f1^-1, f2*f1*f2*f1^-1*f2^-1, f3, f4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List([-5..5],i-&gt;2*SupportingRays(r*twist^i)[2][1][1]);</span>
[ 4/7, 5/7, 4/7, 4/7, 5/7, 2/7, 4/7, 4/7, 2/7, 4/7, 4/7 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r := PolynomialSphereMachine(2,[],[1/6]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := StateSet(r);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">twist := GroupHomomorphismByImages(F,F,GeneratorsOfGroup(F),[F.1,F.2^(F.3*F.2),F.3^F.2,F.4]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SupportingRays(r);</span>
[ 2, [  ], [ [ 1/12, 7/12 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SupportingRays(r*twist);</span>
[ 2, [  ], [ [ 5/12, 11/12 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SupportingRays(r*twist^2);</span>
rec(
  transformation := [ [ f1, f2^-1*f3^-1*f2^-1*f3^-1*f2*f3*f2*f3*f2, f2^-1*f3^-1*f2^-1*f3*f2*f3*f2,
          f4 ] -&gt; [ f1, f2, f3, f4 ],
      [ f1^-1*f2^-1*f1^-1*f2^-1*f1*f2*f1*f2*f1, f1^-1*f2^-1*f1^-1*f2*f1*f2*f1, f3, f4 ] -&gt;
        [ f1, f2, f3, f4 ],
      [ f1^-1*f2^-1*f3^-1*f2*f1*f2^-1*f3*f2*f1, f2, f2*f1^-1*f2^-1*f3*f2*f1*f2^-1, f4 ] -&gt;
        [ f1, f2, f3, f4 ], [ f1, f3*f2*f3^-1, f3, f4 ] -&gt; [ f1, f2, f3, f4 ],
      [ f1, f2, f2*f3*f2^-1, f4 ] -&gt; [ f1, f2, f3, f4 ],
      [ f1, f3*f2*f3^-1, f3, f4 ] -&gt; [ f1, f2, f3, f4 ],
      [ f1, f2, f2*f3*f2^-1, f4 ] -&gt; [ f1, f2, f3, f4 ],
      [ f1, f3*f2*f3^-1, f3, f4 ] -&gt; [ f1, f2, f3, f4 ] ], machine := &lt;FR machine with alphabet
    [ 1, 2 ] and adder f4 on Group( [ f1, f2, f3, f4 ] )/[ f4*f3*f2*f1 ]&gt;, minimal := false,
  submachine := &lt;FR machine with alphabet [ 1, 2 ] and adder f3 on Group( [ f1, f2, f3 ] )&gt;,
  homomorphism := [ f1, f2, f3 ] -&gt; [ f1, f2*f3, f4 ],
  relation := &lt;equivalence relation on &lt;object&gt; &gt;, niter := 8 )
</pre></div>

<p>DeclareAttribute("NormalizedPolynomialSphereMachine",IsSphereMachine);</p>

<p><a id="X7EE9C721802D481B" name="X7EE9C721802D481B"></a></p>

<h5>3.3-3 NormalizedPolynomialSphereMachine</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NormalizedPolynomialSphereMachine</code>( <var class="Arg">m</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: A polynomial sphere machine.</p>

<p>This function returns a new sphere machine, in which the adding element has been put into a standard form <span class="SimpleMath">t=[t,1,dots,1]s</span>, where <span class="SimpleMath">s</span> is the long cycle <span class="SimpleMath">i↦ i-1</span>.</p>

<p>DeclareAttribute("SimplifiedSphereMachine",IsSphereMachine);</p>

<p><a id="X81B7D47D81212C4F" name="X81B7D47D81212C4F"></a></p>

<h5>3.3-4 SimplifiedSphereMachine</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimplifiedSphereMachine</code>( <var class="Arg">m</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: A simpler sphere machine.</p>

<p>This function returns a new sphere machine, with hopefully simpler transitions. The simplified machine is obtained by applying automorphisms to the stateset. The sequence of automorphisms (in increasing order) is stored as a correspondence; namely, if <code class="code">n=SimplifiedSphereMachine(m)</code>, then <code class="code">m^Product(Correspondence(n))=n</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r := PolynomialSphereMachine(2,[1/7],[]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := StateSet(r);; SetName(F,"F");</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">twist := GroupHomomorphismByImages(F,F,GeneratorsOfGroup(F),[F.1^(F.2*F.1),F.2^F.1,F.3,F.4]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := r*twist;; Display(m);</span>
 G  |                     1            2
----+------------------------+------------+
 f1 |          f1^-1*f2^-1,2   f3*f2*f1,1
 f2 | f1^-1*f2^-1*f1*f2*f1,1       &lt;id&gt;,2
 f3 |          f1^-1*f2*f1,1       &lt;id&gt;,2
 f4 |                   f4,2       &lt;id&gt;,1
----+------------------------+------------+
Adding element: f4
Relator: f4*f3*f2*f1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n := SimplifiedSphereMachine(m);</span>
&lt;FR machine with alphabet [ 1, 2 ] and adder f4 on F&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(n);</span>
 G  |            1            2
----+---------------+------------+
 f1 | f2^-1*f1^-1,2   f1*f2*f3,1
 f2 |        &lt;id&gt;,1         f1,2
 f3 |        &lt;id&gt;,1         f2,2
 f4 |          f4,2       &lt;id&gt;,1
----+---------------+------------+
Adding element: f4
Relator: f4*f1*f2*f3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n = m^Product(Correspondence(n));</span>
true
</pre></div>

<p>DeclareOperation("Mating",[IsPolynomialSphereMachine,IsPolynomialSphereMachine]); DeclareOperation("Mating",[IsPolynomialSphereMachine,IsPolynomialSphereMachine,IsBool]);</p>

<p><a id="X7AB029AE8590964E" name="X7AB029AE8590964E"></a></p>

<h5>3.3-5 Mating</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Mating</code>( <var class="Arg">m1</var>, <var class="Arg">m2</var>[, <var class="Arg">formal</var>] )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A sphere machine.</p>

<p>This function "mates" two polynomial sphere machines.</p>

<p>The mating is defined as follows: one removes a disc around the adding machine in <var class="Arg">m1</var> and <var class="Arg">m2</var>; one applies complex conjugation to <var class="Arg">m2</var>; and one glues the hollowed spheres along their boundary circle.</p>

<p>The optional argument <var class="Arg">formal</var>, which defaults to <code class="keyw">true</code>, specifies whether a <em>formal</em> mating should be done; in a non-formal mating, generators of <var class="Arg">m1</var> and <var class="Arg">m2</var> which have identical angle should be treated as a single generator. A non-formal mating is of course possible only if the machines are realizable -- see <code class="func">SupportingRays</code> (<a href="chap3.html#X814E27317A6213D3"><span class="RefLink">3.3-2</span></a>).</p>

<p>The attribute <code class="code">Correspondence</code> is a pair of homomorphisms, from the statesets of <var class="Arg">m1,m2</var> respectively to the stateset of the mating.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># the Tan-Shishikura examples</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z := Indeterminate(MPC_PSEUDOFIELD);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := RootsFloat((z-1)*(3*z^2-2*z^3)+1);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := RootsFloat((z^3+z)^3+z);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">am := List(a,a-&gt;SphereMachine((a-1)*(3*z^2-2*z^3)+1));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cm := List(c,c-&gt;SphereMachine(z^3+c));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := ListX(am,cm,Mating);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># m[2] is realizable</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RationalFunction(m[2]);</span>
((1.66408+I*0.668485)*z^3+(-2.59772+I*0.627498)*z^2+(-1.80694-I*0.833718)*z
  +(1.14397-I*1.38991))/((-1.52357-I*1.27895)*z^3+(2.95502+I*0.234926)*z^2
  +(1.61715+I*1.50244)*z+1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># m[6] is obstructed</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RationalFunction(m[6]);</span>
rec( matrix := [ [ 1/2, 1 ], [ 1/2, 0 ] ], machine := &lt;FR machine with alphabet
    [ 1, 2, 3 ] on Group( [ f1, f2, f3, g1, g2, g3 ] )/[ f2*f3*f1*g1*g3*g2 ]&gt;,
  obstruction := [ f1^-1*f3^-1*f2^-1*f1*f2*f3*f1*g2^-1*g3^-1*f1^-1*f3^-1*f2^-1,
      f2*f3*f1*f2*f3*f1*g2*f1^-1*f3^-1*f2^-1*f1^-1*f3^-1 ],
  spider := &lt;spider on &lt;triangulation with 8 vertices, 36 edges and
    12 faces&gt; marked by GroupHomomorphismByImages( Group( [ f1, f2, f3, g1, g2, g3
     ] ), Group( [ f1, f2, f3, f4, f5 ] ), [ f1, f2, f3, g1, g2, g3 ],
    [ f1*f4*f2^-1*f1*f4^-1*f1^-1, f1*f4*f2^-1*f1*f4*f5^-1*f1^-1*f2*f4^-1*f1^-1,
      f1*f4*f2^-1*f1*f5*f1^-1*f2*f4^-1*f1^-1, f2*f4^-1*f1^-1*f2*f1*f4*f2^-1,
      f2*f4^-1*f3*f2^-1, f2*f4^-1*f1^-1*f3^-1*f4*f2^-1 ] )&gt; )
</pre></div>

<p>DeclareProperty("IsKneadingMachine",IsFRMachine); DeclareProperty("IsPlanarKneadingMachine",IsFRMachine); InstallTrueMethod(IsBoundedFRMachine,IsKneadingMachine); InstallTrueMethod(IsLevelTransitive,IsKneadingMachine);</p>

<p><a id="X84C2881D87C1FB74" name="X84C2881D87C1FB74"></a></p>

<h5>3.3-6 IsKneadingMachine</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsKneadingMachine</code>( <var class="Arg">m</var> )</td><td class="tdright">( property )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPlanarKneadingMachine</code>( <var class="Arg">m</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>Returns: Whether <var class="Arg">m</var> is a (planar) kneading machine.</p>

<p>A <em>kneading machine</em> is a special kind of Mealy machine, used to describe postcritically finite complex polynomials. It is a machine such that its set of permutations is "treelike" (see <a href="chapBib.html#biBMR2162164">[Nek05, §6.7]</a>) and such that each non-trivial state occurs exactly once among the outputs.</p>

<p>Furthermore, this set of permutations is <em>treelike</em> if there exists an ordering of the states that their product in that order <span class="SimpleMath">t</span> is an adding machine; i.e. such that <span class="SimpleMath">t</span>'s activity is a full cycle, and the product of its states along that cycle is conjugate to <span class="SimpleMath">t</span>. This element <span class="SimpleMath">t</span> represents the Carathéodory loop around infinity.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := BinaryKneadingMachine("0");</span>
BinaryKneadingMachine("0*")
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(M);</span>
   |  1     2
---+-----+-----+
 a | c,2   b,1
 b | a,1   c,2
 c | c,1   c,2
---+-----+-----+
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPlanarKneadingMachine(M);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPlanarKneadingMachine(GrigorchukMachine);</span>
false
</pre></div>

<p>DeclareAttribute("AddingElement", IsSphereMachine);</p>

<p><a id="X82F34D5387FF4E57" name="X82F34D5387FF4E57"></a></p>

<h5>3.3-7 AddingElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AddingElement</code>( <var class="Arg">m</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The element generating the adding submachine.</p>

<p>This attribute stores the product of generators that is an adding machine. In essence, it records an ordering of the generators whose product corresponds to the Carathéodory loop around infinity.</p>

<p>The following example illustrates Wittner's shared mating of the airplane and the rabbit. In the machine <code class="code">m</code>, an airplane is represented by <code class="code">Group(a,b,c)</code> and a rabbit is represented by <code class="code">Group(x,y,z)</code>; in the machine <code class="code">newm</code>, it is the other way round. The effect of <code class="code">CleanedIMGMachine</code> was to remove unnecessary instances of the IMG relator from <code class="code">newm</code>'s recursion.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := FreeGroup("a","b","c","x","y","z");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AssignGeneratorVariables(f);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := AsSphereMachine(FRMachine(f,[[a^-1,b*a],[One(f),c],[a,One(f)],[z*y*x,</span>
       x^-1*y^-1],[One(f),x],[One(f),y]],[(1,2),(),(),(1,2),(),()]));;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(m);</span>
 G |      1             2   
---+---------+-------------+
 a |  a^-1,2         b*a,1  
 b |  &lt;id&gt;,1           c,2  
 c |     a,1        &lt;id&gt;,2  
 x | z*y*x,2   x^-1*y^-1,1  
 y |  &lt;id&gt;,1           x,2  
 z |  &lt;id&gt;,1           y,2  
---+---------+-------------+
Relator: z*y*x*c*b*a
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso := GroupHomomorphismByImages(f,f,[a,b^(y^-1),c^(x^-1*y^-1*a^-1),x^(b*a*z*a^-1),y,z^(a^-1)],[a,b,c,x,y,z]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">newm := CleanedSphereMachine(ChangeFRMachineBasis(m^iso,[a^-1*y^-1,y^-1*a^-1*c^-1]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(newm);</span>
 G |          1         2   
---+-------------+---------+
 a | a^-1*c^-1,2   c*a*b,1  
 b |      &lt;id&gt;,1       c,2  
 c |         a,1    &lt;id&gt;,2  
 x |       z*x,2    x^-1,1  
 y |      &lt;id&gt;,1       x,2  
 z |         y,1    &lt;id&gt;,2  
---+-------------+---------+
Relator: c*a*b*y*z*x
</pre></div>

<p>DeclareSynonym("IsPolynomialSphereMachine",IsSphereMachine and HasAddingElement); DeclareAttribute("AsPolynomialSphereMachine",IsFRMachine); DeclareOperation("AsPolynomialSphereMachine",[IsFRMachine,IsWord]);</p>

<p><a id="X7BE171B879357604" name="X7BE171B879357604"></a></p>

<h5>3.3-8 AsPolynomialSphereMachine</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsPolynomialSphereMachine</code>( <var class="Arg">m</var>[, <var class="Arg">adder</var>[, <var class="Arg">relator</var>]] )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A polynomial sphere machine.</p>

<p>The first function creates a new polynomial sphere machine, starting from a group or Mealy machine. A <em>polynomial</em> machine is one that has a distinguished adding element, <code class="func">AddingElement</code> (<a href="chap3.html#X82F34D5387FF4E57"><span class="RefLink">3.3-7</span></a>).</p>

<p>If the argument is a Mealy machine, it must be planar (see <code class="func">IsPlanarKneadingMachine</code> (<a href="chap3.html#X84C2881D87C1FB74"><span class="RefLink">3.3-6</span></a>)). If the argument is a group machine, its permutations must be treelike, and its outputs must be such that, up to conjugation, each non-trivial state appears exactly once as the product along all cycles of all states.</p>

<p>If a second argument <var class="Arg">adder</var> is supplied, it is checked to represent an adding element, and is used as such.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := PolynomialMealyMachine(2,[1/7],[]);</span>
!!!
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Mi := AsPolynomialSphereMachine(M);</span>
!!!
</pre></div>

<p>DeclareOperation("LiftOfConjugacyClass", [IsGroupFRMachine,IsConjugacyClassGroupRep]);</p>

<p><a id="X8692875A793FB66F" name="X8692875A793FB66F"></a></p>

<h5>3.3-9 LiftOfConjugacyClass</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LiftOfConjugacyClass</code>( <var class="Arg">m</var>, <var class="Arg">c</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A list of conjugacy classes and multiplicities.</p>

<p>This command computes the preimage of the conjugacy class <var class="Arg">c</var> by the sphere machine <var class="Arg">m</var>, namely, it applies the wreath recursion to a representative of <var class="Arg">c</var> and collects the products on all cycles. It returns then a list of pairs <code class="code">[cc,len]</code> where <code class="code">cc</code> is the conjugacy class of a product on a cycle, and <code class="code">len</code> is the length of the cycle.</p>

<p>DeclareAttribute("ComplexConjugate", IsFRMachine); # already declared for arithmetic objects</p>

<p><a id="X7BE001A0811CD599" name="X7BE001A0811CD599"></a></p>

<h5>3.3-10 ComplexConjugate</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ComplexConjugate</code>( <var class="Arg">m</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: An FR machine with inverted states.</p>

<p>This function constructs an FR machine whose generating states are the inverses of the original states. If <var class="Arg">m</var> came from a complex rational map <span class="SimpleMath">f(z)</span>, this would construct the machine of the conjugate map <span class="SimpleMath">overlinef(overline z)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := PolynomialSphereMachine(2,[1/7]);</span>
&lt;FR machine with alphabet [ 1, 2 ] and adder FRElement(...,f4) on &lt;object&gt;/[ f4*f3*f2*f1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(a);</span>
 G  |            1            2
----+---------------+------------+
 f1 | f1^-1*f2^-1,2   f3*f2*f1,1
 f2 |          f1,1       &lt;id&gt;,2
 f3 |          f2,1       &lt;id&gt;,2
 f4 |          f4,2       &lt;id&gt;,1
----+---------------+------------+
Adding element: FRElement(...,f4)
Relator: f4*f3*f2*f1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(ComplexConjugate(a));</span>
 G  |            1                     2
----+---------------+---------------------+
 f1 | f1*f2*f3*f4,2   f4^-1*f2^-1*f1^-1,1
 f2 |          f1,1      &lt;identity ...&gt;,2
 f3 |          f2,1      &lt;identity ...&gt;,2
 f4 |          f4,2      &lt;identity ...&gt;,1
----+---------------+---------------------+
Adding element: FRElement(...,f4)
Relator: f1*f2*f3*f4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExternalAngle(a);</span>
{2/7}
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExternalAngle(ComplexConjugate(a));</span>
{6/7}
</pre></div>

<p>DeclareOperation("RotatedSpider", [IsPolynomialSphereMachine]); DeclareOperation("RotatedSpider", [IsPolynomialSphereMachine, IsInt]);</p>

<p><a id="X7E941D2185A1DF3B" name="X7E941D2185A1DF3B"></a></p>

<h5>3.3-11 RotatedSpider</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RotatedSpider</code>( <var class="Arg">m</var>[, <var class="Arg">p</var>] )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A polynomial FR machine with rotated spider at infinity.</p>

<p>This function constructs an isomorphic polynomial FR machine, but with a different numbering of the spider legs at infinity. This rotation is accomplished by conjugating by <code class="code">adder^p</code>, where <code class="code">adder</code> is the adding element of <var class="Arg">m</var>, and <var class="Arg">p</var>, the rotation parameter, is <span class="SimpleMath">1</span> by default.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := PolynomialSphereMachine(3,[1/4]);</span>
&lt;FR machine with alphabet [ 1, 2, 3 ] and adder FRElement(...,f3) on &lt;object&gt;/[ f3*f2*f1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(a);</span>
 G  |      1        2         3
----+---------+--------+---------+
 f1 | f1^-1,2   &lt;id&gt;,3   f2*f1,1
 f2 |    f1,1   &lt;id&gt;,2    &lt;id&gt;,3
 f3 |    f3,3   &lt;id&gt;,1    &lt;id&gt;,2
----+---------+--------+---------+
Adding element: FRElement(...,f3)
Relator: f3*f2*f1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(RotatedSpider(a));</span>
 G  |     1            2               3
----+--------+------------+---------------+
 f1 | &lt;id&gt;,2   f2*f1*f3,3   f3^-1*f1^-1,1
 f2 | &lt;id&gt;,1       &lt;id&gt;,2   f3^-1*f1*f3,3
 f3 |   f3,3       &lt;id&gt;,1          &lt;id&gt;,2
----+--------+------------+---------------+
Adding element: FRElement(...,f3)
Relator: f3*f2*f1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExternalAngle(a);</span>
{3/8}
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List([1..10],i-&gt;ExternalAngle(RotatedSpider(a,i)));</span>
[ {7/8}, {1/4}, {7/8}, {1/4}, {7/8}, {1/4}, {7/8}, {1/4}, {7/8}, {1/4} ]
</pre></div>

<p>DeclareAttribute("KneadingSequence", IsRat);</p>

<p><a id="X86C9E1938159FEE1" name="X86C9E1938159FEE1"></a></p>

<h5>3.3-12 KneadingSequence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; KneadingSequence</code>( <var class="Arg">angle</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The kneading sequence associated with <var class="Arg">angle</var>.</p>

<p>This function converts a rational angle to a kneading sequence, to describe a quadratic polynomial.</p>

<p>If <var class="Arg">angle</var> is in <span class="SimpleMath">[1/7,2/7]</span> and the option <code class="code">marked</code> is set, the kneading sequence is decorated with markings in A,B,C.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KneadingSequence(1/7);</span>
[ 1, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KneadingSequence(1/5:marked);</span>
[ "A1", "B1", "B0" ]
</pre></div>

<p>DeclareGlobalFunction("AllInternalAddresses");</p>

<p><a id="X857FCD7678B12A0C" name="X857FCD7678B12A0C"></a></p>

<h5>3.3-13 AllInternalAddresses</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllInternalAddresses</code>( <var class="Arg">n</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: Internal addresses of maps with period up to <var class="Arg">n</var>.</p>

<p>This function returns internal addresses for all periodic points of period up to <var class="Arg">n</var> under angle doubling. These internal addresses describe the prominent hyperbolic components along the path from the landing point to the main cardioid in the Mandelbrot set; this is a list of length <code class="code">3k</code>, with at position <code class="code">3i+1,3i+2</code> the left and right angles, respectively, and at position <code class="code">3i+3</code> the period of that component. For example, <code class="code">[ 3/7, 4/7, 3, 1/3, 2/3, 2 ]</code> describes the airplane: a polynomial with landing angles <span class="SimpleMath">[3/7,4/7]</span> of period <span class="SimpleMath">3</span>; and such that there is a polynomial with landing angles <span class="SimpleMath">[1/3,2/3]</span> and period <span class="SimpleMath">2</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AllInternalAddresses(3);</span>
[ [  ], [ [ 1/3, 2/3, 2 ] ], 
[ [ 1/7, 2/7, 3 ], [ 3/7, 4/7, 3, 1/3, 2/3, 2 ], [ 5/7, 6/7, 3 ] ] ]
</pre></div>

<p>DeclareGlobalFunction("ExternalAnglesRelation");</p>

<p><a id="X86C250907E09F399" name="X86C250907E09F399"></a></p>

<h5>3.3-14 ExternalAnglesRelation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExternalAnglesRelation</code>( <var class="Arg">degree</var>, <var class="Arg">n</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: An equivalence relation on the rationals.</p>

<p>This function returns the equivalence relation on <code class="code">Rationals</code> identifying all pairs of external angles that land at a common point of period up to <var class="Arg">n</var> under angle multiplication by by <var class="Arg">degree</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExternalAnglesRelation(2,3);</span>
&lt;equivalence relation on Rationals &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EquivalenceRelationPartition(last);</span>
[ [ 1/7, 2/7 ], [ 1/3, 2/3 ], [ 3/7, 4/7 ], [ 5/7, 6/7 ] ]
</pre></div>

<p>DeclareGlobalFunction("ExternalAngle");</p>

<p><a id="X84F962AF7D553DDA" name="X84F962AF7D553DDA"></a></p>

<h5>3.3-15 ExternalAngle</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExternalAngle</code>( <var class="Arg">machine</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The external angle identifying <var class="Arg">machine</var>.</p>

<p>In case <var class="Arg">machine</var> is the sphere machine of a unicritical polynomial, this function computes the external angle landing at the critical value. More precisely, it computes the equivalence class of that external angle under <code class="func">ExternalAnglesRelation</code> (<a href="chap3.html#X86C250907E09F399"><span class="RefLink">3.3-14</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExternalAngle(PolynomialSphereMachine(2,[1/7])); # the rabbit</span>
{2/7}
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Elements(last);</span>
[ 1/7, 2/7 ]
</pre></div>

<p><a id="X7C2EE46F7CFC2CD3" name="X7C2EE46F7CFC2CD3"></a></p>

<h4>3.4 <span class="Heading">Automorphisms of sphere machines</span></h4>

<p>Consider a sphere group <span class="SimpleMath">G</span> and its automorphism group <span class="SimpleMath">A</span>. If <span class="SimpleMath">M</span> is a sphere machine for the group <span class="SimpleMath">G</span>, then pre- and post-composition by automorphisms in <span class="SimpleMath">A</span> gives new sphere machines. The set of such sphere machines is naturally described by a machine for the group <span class="SimpleMath">A</span>. DeclareOperation("AutomorphismVirtualEndomorphism",[IsGroupHomomorphism]); DeclareOperation("AutomorphismSphereMachine",[IsSphereMachine]);</p>

<p><a id="X8410869F8358A1AF" name="X8410869F8358A1AF"></a></p>

<h5>3.4-1 AutomorphismVirtualEndomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AutomorphismVirtualEndomorphism</code>( <var class="Arg">v</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AutomorphismSphereMachine</code>( <var class="Arg">m</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: A description of the pullback map on Teichmüller space.</p>

<p>Let <var class="Arg">m</var> be a sphere machine, thought of as a biset for the fundamental group <span class="SimpleMath">G</span> of a punctured sphere. Let <span class="SimpleMath">M</span> denote the automorphism of the surface, seen as a group of outer automorphisms of <span class="SimpleMath">G</span> that fixes the conjugacy classes of punctures.</p>

<p>Choose an alphabet letter <var class="Arg">a</var>, and consider the virtual endomorphism <span class="SimpleMath">v:G_a-&gt; G</span>. Let <span class="SimpleMath">H</span> denote the subgroup of <span class="SimpleMath">M</span> that fixes all conjugacy classes of <span class="SimpleMath">G_a</span>. then there is an induced virtual endomorphism <span class="SimpleMath">α:H-&gt; M</span>, defined by <span class="SimpleMath">t^α=v^-1tv</span>. This is the homomorphism computed by the first command. Its source and range are in fact groups of automorphisms of range of <var class="Arg">v</var>.</p>

<p>The second command constructs an FR machine associated with <var class="Arg">\alpha</var>. Its stateset is a free group generated by elementary Dehn twists of the generators of <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z := Indeterminate(COMPLEX_FIELD);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># a Sierpinski carpet map without multicurves</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := SphereMachine((z^2-z^-2)/2/COMPLEX_I);</span>
&lt;FR machine with alphabet [ 1, 2, 3, 4 ] on Group( [ f1, f2, f3, f4 ] )/[ f3*f2*f1*f4 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AutomorphismSphereMachine(i);</span>
&lt;FR machine with alphabet [ 1, 2 ] on Group( [ x1, x2, x3, x4, x5, x6 ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(last);</span>
 G  |     1        2
----+--------+--------+
 x1 | &lt;id&gt;,2   &lt;id&gt;,1  
 x2 | &lt;id&gt;,1   &lt;id&gt;,2  
 x3 | &lt;id&gt;,2   &lt;id&gt;,1  
 x4 | &lt;id&gt;,2   &lt;id&gt;,1  
 x5 | &lt;id&gt;,1   &lt;id&gt;,2  
 x6 | &lt;id&gt;,2   &lt;id&gt;,1  
----+--------+--------+
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># the original rabbit problem</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := PolynomialSphereMachine(2,[1/7],[]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v := VirtualEndomorphism(m,1);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := AutomorphismVirtualEndomorphism(v);</span>
MappingByFunction( &lt;group with 20 generators&gt;, &lt;group with 6 generators&gt;, function( a ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Source(a).1;</span>
[ f1, f2, f3, f4 ] -&gt; [ f3*f2*f1*f2^-1*f3^-1, f2, f3, f3*f2*f1^-1*f2^-1*f3^-1*f2^-1*f3^-1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Image(a,last);</span>
[ f1, f2, f3, f4 ] -&gt; [ f1, f2, f2*f1*f3*f1^-1*f2^-1, f3^-1*f1^-1*f2^-1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># so last2*m is equivalent to m*last</span>
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
