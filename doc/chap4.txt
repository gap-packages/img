  
  [1X4 [33X[0;0YHolomorphic maps[133X[101X
  
  [33X[0;0YA  large  part  of  [5XIMG[105X  consists of code that manipulates rational maps and
  complex coordinates on spheres.[133X
  
  
  [1X4.1 [33X[0;0Y[22XP^1[122X[101X[1X points[133X[101X
  
  [33X[0;0YPoints  on the sphere are represented by complex numbers, possibly infinity.
  These   complex   numbers  are  encapsulated  in  [2XP1Point[102X  ([14X4.1-1[114X)  objects.
  DeclareCategory("IsP1Point",IsObject);
  DeclareCategoryCollections("IsP1Point");
  DeclareCategoryCollections("IsP1PointCollection");
  DeclareSynonym("IsP1PointList",IsP1PointCollection        and       IsList);
  DeclareCategory("IsIEEE754P1Point",IsP1Point);
  BindGlobal("P1PointsFamily",NewFamily("P1PointsFamily",IsP1Point));
  BindGlobal("TYPE_P1POINT",NewType(P1PointsFamily,IsP1Point               and
  IsPositionalObjectRep));
  BindGlobal("TYPE_IEEE754P1POINT",NewType(P1PointsFamily,IsIEEE754P1Point and
  IsDataObjectRep));                    DeclareOperation("P1Point",[IsFloat]);
  DeclareOperation("P1Point",[IsRat]);
  DeclareOperation("P1Point",[IsInfinity]);
  DeclareOperation("P1Point",[IsFloat,IsFloat]);
  DeclareOperation("P1Point",[IsString]);
  DeclareOperation("P1Point",[IsString,IsString]);[133X
  
  [1X4.1-1 IsP1Point[101X
  
  [33X[1;0Y[29X[2XIsP1Point[102X[32X filter[133X
  [33X[1;0Y[29X[2XP1PointsFamily[102X[32X family[133X
  [33X[1;0Y[29X[2XP1Point[102X( [3Xcomplex[103X ) [32X function[133X
  [33X[1;0Y[29X[2XP1Point[102X( [3Xreal[103X, [3Ximag[103X ) [32X function[133X
  [33X[1;0Y[29X[2XP1Point[102X( [3Xstring[103X ) [32X function[133X
  [33X[1;0Y[29X[2XP1Point[102X( [3Xrealstr[103X, [3Ximagstr[103X ) [32X function[133X
  
  [33X[0;0YP1  points  are complex numbers or infinity; fast methods are implemented to
  compute with them, and to apply rational maps to them.[133X
  
  [33X[0;0YThe  first filter recognizes these objects. Next, the family they belong to.
  The next methods create a new P1 point.[133X
  
  [33X[0;0YDeclareAttribute("P1Coordinate",IsP1Point);[133X
  
  [1X4.1-2 P1Coordinate[101X
  
  [33X[1;0Y[29X[2XP1Coordinate[102X( [3Xp[103X ) [32X function[133X
  [6XReturns:[106X  [33X[0;10YThe complex number represented by [3Xp[103X.[133X
  
  [33X[0;0YDeclareOperation("CleanedP1Point",[IsP1Point,IsFloat]);
  DeclareOperation("CleanedP1Point",[IsP1Point]);[133X
  
  [1X4.1-3 CleanedP1Point[101X
  
  [33X[1;0Y[29X[2XCleanedP1Point[102X( [3Xp[103X[, [3Xprec[103X] ) [32X function[133X
  [6XReturns:[106X  [33X[0;10Y[3Xp[103X, rounded towards 0/1/infinity/reals at precision [3Xprec[103X.[133X
  
  [33X[0;0YDeclareGlobalVariable("P1infinity");
  DeclareOperation("P1INFINITY@",[IsP1Point]); DeclareGlobalVariable("P1one");
  DeclareGlobalVariable("P1zero");[133X
  
  [1X4.1-4 P1infinity[101X
  
  [33X[1;0Y[29X[2XP1infinity[102X[32X global variable[133X
  [33X[1;0Y[29X[2XP1one[102X[32X global variable[133X
  [33X[1;0Y[29X[2XP1zero[102X[32X global variable[133X
  
  [33X[0;0YThe south, north and 'east' poles of the Riemann sphere.[133X
  
  [33X[0;0YDeclareAttribute("P1Antipode",IsP1Point);[133X
  
  [1X4.1-5 P1Antipode[101X
  
  [33X[1;0Y[29X[2XP1Antipode[102X( [3Xp[103X ) [32X function[133X
  [6XReturns:[106X  [33X[0;10YThe antipode of [3Xp[103X on the Riemann sphere.[133X
  
  [33X[0;0YDeclareOperation("P1Barycentre",[IsP1PointList]);
  DeclareOperation("P1Barycentre",[IsP1Point]);
  DeclareOperation("P1Barycentre",[IsP1Point,IsP1Point]);
  DeclareOperation("P1Barycentre",[IsP1Point,IsP1Point,IsP1Point]);[133X
  
  [1X4.1-6 P1Barycentre[101X
  
  [33X[1;0Y[29X[2XP1Barycentre[102X( [3Xpoints[103X, [3X...[103X ) [32X function[133X
  [6XReturns:[106X  [33X[0;10YThe  barycentre  of  its arguments (which can also be a list of P1
            points).[133X
  
  [33X[0;0YDeclareOperation("P1Circumcentre",[IsP1Point,IsP1Point,IsP1Point]);[133X
  
  [1X4.1-7 P1Circumcentre[101X
  
  [33X[1;0Y[29X[2XP1Circumcentre[102X( [3Xp[103X, [3Xq[103X, [3Xr[103X ) [32X function[133X
  [6XReturns:[106X  [33X[0;10YThe centre of the smallest disk containing [3Xp,q,r[103X.[133X
  
  [33X[0;0YDeclareOperation("P1Distance",[IsP1Point,IsP1Point]);[133X
  
  [1X4.1-8 P1Distance[101X
  
  [33X[1;0Y[29X[2XP1Distance[102X( [3Xp[103X, [3Xq[103X ) [32X function[133X
  [6XReturns:[106X  [33X[0;10YThe spherical distance from [3Xp[103X to [3Xq[103X.[133X
  
  [33X[0;0YDeclareOperation("P1Midpoint",[IsP1Point,IsP1Point]);[133X
  
  [1X4.1-9 P1Midpoint[101X
  
  [33X[1;0Y[29X[2XP1Midpoint[102X( [3Xp[103X, [3Xq[103X ) [32X function[133X
  [6XReturns:[106X  [33X[0;10YThe  point between [3Xp[103X to [3Xq[103X (undefined if they are antipodes of each
            other).[133X
  
  [33X[0;0YDeclareAttribute("P1Sphere",IsList);[133X
  
  [1X4.1-10 P1Sphere[101X
  
  [33X[1;0Y[29X[2XP1Sphere[102X( [3Xv[103X ) [32X function[133X
  [6XReturns:[106X  [33X[0;10YThe P1 point corresponding to [3Xv[103X in [22XR^3[122X.[133X
  
  [33X[0;0YDeclareAttribute("SphereP1",IsP1Point);[133X
  
  [1X4.1-11 SphereP1[101X
  
  [33X[1;0Y[29X[2XSphereP1[102X( [3Xp[103X ) [32X function[133X
  [6XReturns:[106X  [33X[0;10YThe coordinates in [22XR^3[122X of [3Xp[103X.[133X
  
  [33X[0;0YDeclareAttribute("SphereP1Y",IsP1Point);[133X
  
  [1X4.1-12 SphereP1Y[101X
  
  [33X[1;0Y[29X[2XSphereP1Y[102X( [3Xp[103X ) [32X function[133X
  [6XReturns:[106X  [33X[0;10YThe Y coordinate in [22XR^3[122X of [3Xp[103X.[133X
  
  [33X[0;0YDeclareOperation("P1XRatio",[IsP1Point,IsP1Point,IsP1Point,IsP1Point]);
  DeclareOperation("XRatio",[IsP1Point,IsP1Point,IsP1Point,IsP1Point]);[133X
  
  [1X4.1-13 P1XRatio[101X
  
  [33X[1;0Y[29X[2XP1XRatio[102X( [3Xp[103X, [3Xq[103X, [3Xr[103X, [3Xs[103X ) [32X function[133X
  [33X[1;0Y[29X[2XXRatio[102X( [3Xp[103X, [3Xq[103X, [3Xr[103X, [3Xs[103X ) [32X function[133X
  [6XReturns:[106X  [33X[0;10YThe cross ratio of [3Xp, q, r, s[103X.[133X
  
  [33X[0;0YThe  cross ratio of four points [3Xp,q,r,s[103X is defined as [10X(p-r)(q-s)/(p-s)(q-r)[110X.
  The  values  [10XP1zero,P1one,P1infinity[110X  correspond respectively to the special
  cases [10X(p=r or q=s)[110X, [10X(p=q or r=s)[110X, [10X(p=s or q=r)[110X.[133X
  
  [33X[0;0YIn  the  first  form,  the result is a P1 point. In the second form, it is a
  complex number.[133X
  
  [33X[0;0YDeclareOperation("CollectedP1Points",[IsP1PointList]);
  DeclareOperation("CollectedP1Points",[IsP1PointList,IsFloat]);[133X
  
  [1X4.1-14 CollectedP1Points[101X
  
  [33X[1;0Y[29X[2XCollectedP1Points[102X( [3Xp1points[103X[, [3Xprecision[103X] ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YA list of pairs [10X[point,multiplicity][110X.[133X
  
  [33X[0;0YCollects  the  points  in [3Xp1points[103X; points at distance at most [3Xprecision[103X are
  considered equal, and the barycentre of the clustered points is returned.[133X
  
  [33X[0;0YIf the argument [3Xprecision[103X is not supplied, [10X@IMG.p1eps[110X is taken.[133X
  
  [33X[0;0YDeclareOperation("MatchP1Points",[IsP1PointList,IsP1PointCollColl,IsFloat]);
  DeclareOperation("MatchP1Points",[IsP1PointList,IsP1PointCollColl]);[133X
  
  [1X4.1-15 MatchP1Points[101X
  
  [33X[1;0Y[29X[2XMatchP1Points[102X( [3Xp1pointsA[103X, [3Xp1pointsB[103X[, [3Xseparation[103X] ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YA  list  of  giving  closest  point  in  [3Xp1pointsB[103X  to  points  in
            [3Xp1pointsA[103X, or [9Xfail[109X.[133X
  
  [33X[0;0YFinds  for  each point [3Xp1pointsA[i][103X the closest point [3Xp1pointB[p[i]][103X. If the
  next-closest  is at least [3Xseparation[103X further away for all [10Xi[110X, then the list [10Xp[110X
  is returned. Otherwise, [9Xfail[109X is returned.[133X
  
  [33X[0;0YIf the argument [3Xseparation[103X is not supplied, [9X2[109X is taken.[133X
  
  [33X[0;0YDeclareOperation("ClosestP1Point",[IsP1PointList,IsP1Point]);[133X
  
  [1X4.1-16 ClosestP1Point[101X
  
  [33X[1;0Y[29X[2XClosestP1Point[102X( [3Xp1points[103X, [3Xp1point[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YThe point in [3Xp1points[103X closest to [3Xp1point[103X.[133X
  
  [33X[0;0YDeclareSynonym("IsP1Map",HasIsUnivariateRationalFunction                 and
  IsUnivariateRationalFunction          and          IsFloatRationalFunction);
  DeclareCategory("IsIEEE754P1Map",IsP1Map);   BindGlobal("TYPE_IEEE754P1MAP",
  NewType(RationalFunctionsFamily(PMCOMPLEX_PSEUDOFIELD),  IsIEEE754P1Map  and
  IsDataObjectRep));[133X
  
  [1X4.1-17 IsP1Map[101X
  
  [33X[1;0Y[29X[2XIsP1Map[102X[32X filter[133X
  
  [33X[0;0YP1  maps  are  stored  more  efficiently  than  rational  functions, but are
  otherwise equivalent.[133X
  
  [33X[0;0YDeclareOperation("MoebiusMap",[IsP1Point]);
  DeclareOperation("MoebiusMap",[IsP1Point,IsP1Point]);
  DeclareOperation("MoebiusMap",[IsP1Point,IsP1Point,IsP1Point]);
  DeclareOperation("MoebiusMap",[IsP1Point,IsP1Point,IsP1Point,IsP1Point,IsP1Point,IsP1Point]);
  DeclareOperation("MoebiusMap",[IsP1PointList]);
  DeclareOperation("MoebiusMap",[IsP1PointList,IsP1PointList]);[133X
  
  [1X4.1-18 MoebiusMap[101X
  
  [33X[1;0Y[29X[2XMoebiusMap[102X( [[3Xsourcelist[103X, ][3Xdestlist[103X ) [32X function[133X
  [33X[1;0Y[29X[2XMoebiusMap[102X( [3Xp[103X, [3Xq[103X, [3Xr[103X, [3Xs[103X, [3Xt[103X, [3Xu[103X ) [32X function[133X
  [33X[1;0Y[29X[2XMoebiusMap[102X( [3Xp[103X, [3Xq[103X, [3Xr[103X ) [32X function[133X
  [33X[1;0Y[29X[2XMoebiusMap[102X( [3Xp[103X, [3Xq[103X ) [32X function[133X
  [33X[1;0Y[29X[2XMoebiusMap[102X( [3Xp[103X ) [32X function[133X
  [6XReturns:[106X  [33X[0;10YA new M√∂bius transformation.[133X
  
  [33X[0;0YIn  the first case, this is the M√∂bius transformation sending [3Xp,q,r[103X to [3XP,Q,R[103X
  respectively;  in  the  second case, the map sending [10X0,1,P1infinity[110X to [3Xp,q,r[103X
  respectively;  in  the  third  case,  the  map  sending  [10X0,P1infinity[110X to [3Xp,q[103X
  respectively,  and  of  the  form  [22X(z-p)/(z-q)[122X;  and  in  the fourth case, a
  rotation sending [3XP1infinity[103X to [3Xp[103X.[133X
  
  [33X[0;0YDeclareOperation("P1ROTATION@",[IsP1Point,IsP1PointList,IsP1PointList]);
  DeclareGlobalFunction("P1MapRotatingP1Points");[133X
  
  [1X4.1-19 P1MapRotatingP1Points[101X
  
  [33X[1;0Y[29X[2XP1MapRotatingP1Points[102X( [3Xpoints[103X[, [3Xoldpoints[103X] ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YA M√∂bius rotation sending the last of [3Xpoints[103X to P1infinity.[133X
  
  [33X[0;0YA  M√∂bius  rotation  is computed that sends the last of [3Xpoints[103X to [9XP1infinity[109X
  and,  assuming  the  last point in [3Xoldpoints[103X is also [9XP1infinity[109X, matches the
  points in [3Xpoints[103X and [3Xoldpoints[103X as closely as possible.[133X
  
  [33X[0;0YDeclareOperation("P1MapNormalizingP1Points",[IsP1PointList]);
  DeclareOperation("P1MapNormalizingP1Points",[IsP1PointList,IsP1PointList]);[133X
  
  [1X4.1-20 P1MapNormalizingP1Points[101X
  
  [33X[1;0Y[29X[2XP1MapNormalizingP1Points[102X( [3Xpoints[103X[, [3Xoldpoints[103X] ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YA M√∂bius transformation sending the last of [3Xpoints[103X to P1infinity.[133X
  
  [33X[0;0YA  M√∂bius  transformation  is  computed  that  sends  the  last of [3Xpoints[103X to
  [9XP1infinity[109X  and  makes  the  barycentre  of  the  points  in [22XR^3[122X as close as
  possible  to  the  origin.  If  a  list  [3Xoldpoints[103X is also given, the M√∂bius
  transformation  computed rotates about infinity so as to match the points in
  [3Xpoints[103X  and  [3Xoldpoints[103X  as  closely  as  possible;  this then determines the
  transformation uniquely.[133X
  
  [33X[0;0YDeclareGlobalVariable("P1z");[133X
  
  [1X4.1-21 P1z[101X
  
  [33X[1;0Y[29X[2XP1z[102X[32X global variable[133X
  
  [33X[0;0YThe identity M√∂bius transformation.[133X
  
  [33X[0;0YDeclareGlobalFunction("P1Monomial");[133X
  
  [1X4.1-22 P1Monomial[101X
  
  [33X[1;0Y[29X[2XP1Monomial[102X( [3Xn[103X ) [32X function[133X
  [6XReturns:[106X  [33X[0;10YThe rational function [22Xz^n[122X.[133X
  
  [33X[0;0YDeclareOperation("CleanedP1Map",[IsP1Map,IsFloat]);
  DeclareOperation("CleanedP1Map",[IsP1Map]);[133X
  
  [1X4.1-23 CleanedP1Map[101X
  
  [33X[1;0Y[29X[2XCleanedP1Map[102X( [3Xmap[103X[, [3Xprec[103X] ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10Y[3Xmap[103X, with coefficients rounded using [3Xprec[103X.[133X
  
  [33X[0;0YDeclareSynonym("CompositionP1Map",CompositionMapping2);[133X
  
  [1X4.1-24 CompositionP1Map[101X
  
  [33X[1;0Y[29X[2XCompositionP1Map[102X( [3Xmap1[103X, [3X...[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YThe composition of the maps passed as arguments, in the functional
            ([3Xmap1[103X last) order.[133X
  
  [33X[0;0YDeclareSynonym("InverseP1Map",InverseGeneralMapping);[133X
  
  [1X4.1-25 InverseP1Map[101X
  
  [33X[1;0Y[29X[2XInverseP1Map[102X( [3Xmap[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YThe functional inverse of the M√∂bius transformation [3Xmap[103X.[133X
  
  [33X[0;0YDeclareAttribute("ComplexConjugate",IsP1Map);  # already there for numerical
  objects[133X
  
  [1X4.1-26 ComplexConjugate[101X
  
  [33X[1;0Y[29X[2XComplexConjugate[102X( [3Xmap[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YThe complex conjugated map.[133X
  
  [33X[0;0YDeclareOperation("ConjugatedP1Map",[IsP1Map,IsP1Map]);[133X
  
  [1X4.1-27 ConjugatedP1Map[101X
  
  [33X[1;0Y[29X[2XConjugatedP1Map[102X( [3Xmap[103X, [3Xmobius[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YThe map [10XCompositionP1Map(InverseP1Map(mobius),map,mobius)[110X.[133X
  
  [33X[0;0YDeclareAttribute("CoefficientsOfP1Map",IsP1Map);[133X
  
  [1X4.1-28 CoefficientsOfP1Map[101X
  
  [33X[1;0Y[29X[2XCoefficientsOfP1Map[102X( [3Xmap[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YCoefficients  of  numerator  and denominator of [3Xmap[103X, lowest degree
            first.[133X
  
  [33X[0;0YDeclareGlobalFunction("P1MapByCoefficients");
  DeclareOperation("P1MAPBYCOEFFICIENTS2@",[IsObject,IsList,IsList]);[133X
  
  [1X4.1-29 P1MapByCoefficients[101X
  
  [33X[1;0Y[29X[2XP1MapByCoefficients[102X( [3Xnumer[103X, [3Xdenom[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YThe  P1  map  with  numerator  coefficients  [3Xnumer[103X and denominator
            [3Xdenom[103X, lowest degree first.[133X
  
  [33X[0;0YDeclareAttribute("NumeratorP1Map",IsP1Map);
  DeclareAttribute("DenominatorP1Map",IsP1Map);[133X
  
  [1X4.1-30 NumeratorP1Map[101X
  
  [33X[1;0Y[29X[2XNumeratorP1Map[102X( [3Xmap[103X ) [32X attribute[133X
  [33X[1;0Y[29X[2XDenominatorP1Map[102X( [3Xmap[103X ) [32X attribute[133X
  [6XReturns:[106X  [33X[0;10YThe numerator/denominator of [3Xmap[103X.[133X
  
  [33X[0;0YDeclareOperation("P1MapByZerosPoles",[IsP1PointList,IsP1PointList,IsP1Point,IsP1Point]);[133X
  
  [1X4.1-31 P1MapByZerosPoles[101X
  
  [33X[1;0Y[29X[2XP1MapByZerosPoles[102X( [3Xzeros[103X, [3Xpoles[103X, [3Xsrc[103X, [3Xdest[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YThe  P1  map  with  specified  zeros and poles, and sending [3Xsrc[103X to
            [3Xdest[103X.[133X
  
  [33X[0;0YDeclareOperation("P1Path",[IsP1Point,IsP1Point]);[133X
  
  [1X4.1-32 P1Path[101X
  
  [33X[1;0Y[29X[2XP1Path[102X( [3Xp[103X, [3Xq[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YThe P1 map sending [10X0[110X to [3Xp[103X and [10X1[110X to [3Xq[103X.[133X
  
  [33X[0;0YDeclareAttribute("DegreeOfP1Map",IsP1Map);[133X
  
  [1X4.1-33 DegreeOfP1Map[101X
  
  [33X[1;0Y[29X[2XDegreeOfP1Map[102X( [3Xmap[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YThe degree of [3Xmap[103X.[133X
  
  [33X[0;0YDeclareSynonym("P1Image",ImageElm);
  DeclareOperation("ImageElm",[IsP1Map,IsP1Point]);[133X
  
  [1X4.1-34 P1Image[101X
  
  [33X[1;0Y[29X[2XP1Image[102X( [3Xmap[103X, [3Xp1point[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YThe image of [3Xp1point[103X under [3Xmap[103X.[133X
  
  [33X[0;0YDeclareSynonym("P1PreImage",PreImageElm);
  DeclareOperation("PreImageElm",[IsP1Map,IsP1Point]);[133X
  
  [1X4.1-35 P1PreImage[101X
  
  [33X[1;0Y[29X[2XP1PreImage[102X( [3Xmap[103X, [3Xp1point[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YThe preimage of [3Xp1point[103X under [3Xmap[103X.[133X
  
  [33X[0;0YDeclareSynonym("P1PreImages",PreImagesElm);
  DeclareOperation("PreImagesElm",[IsP1Map,IsP1Point]);[133X
  
  [1X4.1-36 P1PreImages[101X
  
  [33X[1;0Y[29X[2XP1PreImages[102X( [3Xmap[103X, [3Xp1point[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YThe preimages of [3Xp1point[103X under [3Xmap[103X.[133X
  
  [33X[0;0YDeclareAttribute("Primitive",IsP1Map);
  DeclareAttribute("Derivative",IsP1Map);[133X
  
  [1X4.1-37 Primitive[101X
  
  [33X[1;0Y[29X[2XPrimitive[102X( [3Xmap[103X ) [32X operation[133X
  [33X[1;0Y[29X[2XDerivative[102X( [3Xmap[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YThe [anti]derivative of the rational map [3Xmap[103X.[133X
  
  [33X[0;0YDeclareOperation("P1MapScaling",[IsP1Map,IsP1Point]);[133X
  
  [1X4.1-38 P1MapScaling[101X
  
  [33X[1;0Y[29X[2XP1MapScaling[102X( [3Xmap[103X, [3Xp1point[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YThe scaling factor from [3Xpoint[103X to [3Xmap(point)[103X.[133X
  
  [33X[0;0YDeclareAttribute("CriticalPointsOfP1Map",IsP1Map);[133X
  
  [1X4.1-39 CriticalPointsOfP1Map[101X
  
  [33X[1;0Y[29X[2XCriticalPointsOfP1Map[102X( [3Xmap[103X ) [32X attribute[133X
  [6XReturns:[106X  [33X[0;10YThe critical points of [3Xmap[103X.[133X
  
  [33X[0;0YDeclareAttribute("AsP1Map",IsScalar);[133X
  
  [1X4.1-40 AsP1Map[101X
  
  [33X[1;0Y[29X[2XAsP1Map[102X( [3Xrat[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YThe P1 map given by the rational function [3Xrat[103X.[133X
  
  [33X[0;0YDeclareOperation("P1MapSL2",[IsMatrix]);[133X
  
  [1X4.1-41 P1MapSL2[101X
  
  [33X[1;0Y[29X[2XP1MapSL2[102X( [3Xmat[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YThe M√∂bius P1 map given by the 2x2 matrix [3Xmat[103X.[133X
  
  [33X[0;0YDeclareAttribute("SL2P1Map",IsP1Map);[133X
  
  [1X4.1-42 SL2P1Map[101X
  
  [33X[1;0Y[29X[2XSL2P1Map[102X( [3Xmap[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YThe matrix of the M√∂bius P1 map [3Xmap[103X.[133X
  
  [33X[0;0YDeclareGlobalFunction("SetP1Points");[133X
  
  [1X4.1-43 SetP1Points[101X
  
  [33X[1;0Y[29X[2XSetP1Points[102X( [3Xrecord[103X[, [3Xprec[103X] ) [32X function[133X
  
  [33X[0;0YInstalls  a  default implementation for P1 points. Fundamentally, a P1 point
  is  a  complex  number  or  infinity, with a few extra methods. The argument
  [3Xrecord[103X is the record describing the floating-point implementation.[133X
  
  [33X[0;0YCurrently,  one  implementation  (the  default) is based on pairs of IEEE754
  floateans.  It is fast, but is limited to 53 bits of precision. It is loaded
  via [10XSetP1Points(PMCOMPLEX);[110X.[133X
  
  [33X[0;0YAnother  implementation, in case the package [5XFloat[105X is available, is based on
  MPC  complex  numbers. It offers unlimited precision, but is much slower. It
  is loaded via [10XSetP1Points(MPC);[110X or [10XSetP1Points(MPC,prec);[110X.[133X
  
  
  [1X4.2 [33X[0;0YTriangulations[133X[101X
  
  [33X[0;0YThe  next  objects  are  finite  triangulations  of  the  sphere.  They  are
  represented by lists of points, edges and faces, and all adjacency relations
  between  them.  Each point, edge and face has a [2XP1Point[102X ([14X4.1-1[114X) as position,
  and  furthermore  edges  come  with  a parametrization [22XŒ≥([0,1])[122X for a M√∂bius
  transformation    [22XŒ≥[122X.   DeclareCategory("IsSphereTriangulation",   IsObject);
  BindGlobal("TRIANGULATION_FAMILY",         NewFamily("SphereTriangulations",
  IsSphereTriangulation));                    BindGlobal("TYPE_TRIANGULATION",
  NewType(TRIANGULATION_FAMILY,                       IsSphereTriangulation));
  DeclareRepresentation("IsTriangulationObjectRep",  IsComponentObjectRep  and
  IsAttributeStoringRep,[]);
  DeclareCategory("IsTriangulationObject",IsTriangulationObjectRep);
  DeclareCategory("IsTriangulationVertex",IsTriangulationObject);
  DeclareCategory("IsTriangulationEdge",IsTriangulationObject);
  DeclareCategory("IsTriangulationFace",IsTriangulationObject);
  BindGlobal("TRIANGULATIONOBJECT_FAMILY",
  NewFamily("TriangulationFamily",IsTriangulationObject,CanEasilySortElements,CanEasilySortElements));
  BindGlobal("TYPE_VERTEX",
  NewType(TRIANGULATIONOBJECT_FAMILY,IsTriangulationVertex));
  BindGlobal("TYPE_EDGE",
  NewType(TRIANGULATIONOBJECT_FAMILY,IsTriangulationEdge));
  BindGlobal("TYPE_FACE",
  NewType(TRIANGULATIONOBJECT_FAMILY,IsTriangulationFace));
  DeclareAttribute("Neighbour",                        IsTriangulationVertex);
  DeclareOperation("Neighbours",                     [IsTriangulationVertex]);
  DeclareOperation("Neighbours", [IsTriangulationVertex,IsTriangulationEdge]);
  DeclareOperation("Valency",                        [IsTriangulationVertex]);
  DeclareAttribute("Pos",                              IsTriangulationVertex);
  DeclareOperation("ClosestFace",                    [IsTriangulationObject]);
  DeclareOperation("ClosestFaces",                   [IsTriangulationObject]);
  DeclareOperation("ClosestVertex",                  [IsTriangulationObject]);
  DeclareOperation("ClosestVertices",                [IsTriangulationObject]);
  DeclareProperty("IsFake",  IsTriangulationVertex);  DeclareAttribute("Left",
  IsTriangulationEdge);     DeclareAttribute("Right",    IsTriangulationEdge);
  DeclareAttribute("To",     IsTriangulationEdge);    DeclareAttribute("From",
  IsTriangulationEdge);   DeclareAttribute("NextEdge",   IsTriangulationEdge);
  DeclareOperation("Next", [IsTriangulationEdge]); DeclareAttribute("Prevopp",
  IsTriangulationEdge);   DeclareAttribute("Opposite",   IsTriangulationEdge);
  DeclareAttribute("Pos",   IsTriangulationEdge);  DeclareAttribute("FromPos",
  IsTriangulationEdge);     DeclareAttribute("ToPos",    IsTriangulationEdge);
  DeclareAttribute("Length",   IsTriangulationEdge);   DeclareAttribute("Map",
  IsTriangulationEdge);  DeclareAttribute("GroupElement", IsTriangulationEdge,
  "mutable");        DeclareAttribute("Neighbour",       IsTriangulationFace);
  DeclareOperation("Neighbours",                       [IsTriangulationFace]);
  DeclareOperation("Neighbours",   [IsTriangulationFace,IsTriangulationEdge]);
  DeclareAttribute("Pos",   IsTriangulationFace);   DeclareAttribute("Radius",
  IsTriangulationFace);    DeclareAttribute("Centre",    IsTriangulationFace);
  DeclareOperation("Valency", [IsTriangulationFace]); DeclareOperation("Draw",
  [IsSphereTriangulation]);[133X
  
  [1X4.2-1 IsSphereTriangulation[101X
  
  [33X[1;0Y[29X[2XIsSphereTriangulation[102X[32X filter[133X
  
  [33X[0;0YThe category of triangulated spheres (points in Moduli space).[133X
  
  [33X[0;0YThis  triangulation  is a collection of vertices, edges and faces. These are
  new GAP objects. The attributes for vertices are:[133X
  
  [8X[10XNeighbour[110X[8X[108X
        [33X[0;6Yany edge starting at the vertex[133X
  
  [8X[10XNeighbours[110X[8X[108X
        [33X[0;6Ya list of neighbours, in counterclockwise order (an optional adugument
        lets one specify the starting edge)[133X
  
  [8X[10XValency[110X[8X[108X
        [33X[0;6Ythe number of neighbours[133X
  
  [8X[10XPos[110X[8X[108X
        [33X[0;6YThe P1 point where the vertex is located[133X
  
  [8X[10XClosestVertex[110X[8X[108X
        [33X[0;6YThe vertex itself[133X
  
  [8X[10XClosestVertices[110X[8X[108X
        [33X[0;6YA list containing the vertex itself[133X
  
  [8X[10XClosestFace[110X[8X[108X
        [33X[0;6YThe face left of the first neighbour[133X
  
  [8X[10XClosestFaces[110X[8X[108X
        [33X[0;6YThe faces that contain the vertex[133X
  
  [8X[10XIsFake[110X[8X[108X
        [33X[0;6Ywhether the vertex was added for refinement[133X
  
  [33X[0;0YThe  edges  come  in  opposite pairs, and are thought of as having a face on
  their left. Their possible attributes are:[133X
  
  [8X[10XLeft[110X[8X, [10XRight[110X[8X[108X
        [33X[0;6YThe adjacent faces[133X
  
  [8X[10XTo[110X[8X, [10XFrom[110X[8X[108X
        [33X[0;6YThe vertices that the edge goes to/from[133X
  
  [8X[10XNext[110X[8X[108X
        [33X[0;6YThe edge after on the left face (starting where the present edge ends)[133X
  
  [8X[10XPrevopp[110X[8X[108X
        [33X[0;6YThe  opposite  of the edge before on the left face (starting where the
        present edge starts)[133X
  
  [8X[10XOpposite[110X[8X[108X
        [33X[0;6YThe opposite edge (with reversed orientation)[133X
  
  [8X[10XPos[110X[8X[108X
        [33X[0;6YThe position of the midpoint. [10XFromPos[110X and [10XToPos[110X are shortcuts[133X
  
  [8X[10XLength[110X[8X[108X
  [8X[10XMap[110X[8X[108X
        [33X[0;6YA P1 map sending [22X[0,1][122X to the edge[133X
  
  [8X[10XGroupElement[110X[8X[108X
        [33X[0;6YA group element describing "crossing through the edge from the left to
        the right"[133X
  
  [8X[10XClosestVertex[110X[8X[108X
        [33X[0;6YThe from vertex[133X
  
  [8X[10XClosestVertices[110X[8X[108X
        [33X[0;6YThe two endpoints[133X
  
  [8X[10XClosestFace[110X[8X[108X
        [33X[0;6YThe left neighbour[133X
  
  [8X[10XClosestFaces[110X[8X[108X
        [33X[0;6YThe two adjacent faces[133X
  
  [33X[0;0YThe faces have the following possible attributes:[133X
  
  [8X[10XNeighbour[110X[8X[108X
        [33X[0;6YSome edge with this face on its left[133X
  
  [8X[10XNeighbours[110X[8X[108X
        [33X[0;6YThe  neighbours of the face, in counterclockwise order around the face
        (an optional argument lets one specify the starting edge)[133X
  
  [8X[10XPos[110X[8X[108X
        [33X[0;6YThe position of the face's barycentre[133X
  
  [8X[10XRadius[110X[8X, [10XCentre[110X[8X[108X
        [33X[0;6YThe  circumradius  and  circumcentre  of  the  face  (assumed  to be a
        triangle)[133X
  
  [8X[10XValency[110X[8X[108X
        [33X[0;6YThe number of neighbouring edges[133X
  
  [8X[10XClosestVertex[110X[8X[108X
        [33X[0;6YThe from of the first neighbour[133X
  
  [8X[10XClosestVertices[110X[8X[108X
        [33X[0;6YThe vertices that the face contains[133X
  
  [8X[10XClosestFace[110X[8X[108X
        [33X[0;6YThe face itself[133X
  
  [8X[10XClosestFaces[110X[8X[108X
        [33X[0;6YA list containing the face itself[133X
  
  [33X[0;0YA  triangulation  may be plotted with [10XDraw[110X; this requires [5Xappletviewer[105X to be
  installed.  The  command  [10XDraw(t:detach)[110X detaches the subprocess after it is
  started.  The  extra  arguments  [10XDraw(t:lower)[110X  or [10XDraw(t:upper)[110X stretch the
  triangulation to the lower, respectively upper, hemisphere.[133X
  
  [33X[0;0YDeclareOperation("EdgePath",
  [IsSphereTriangulation,IsTriangulationFace,IsTriangulationFace]);[133X
  
  [1X4.2-2 EdgePath[101X
  
  [33X[1;0Y[29X[2XEdgePath[102X( [3Xt[103X, [3Xf0[103X, [3Xf1[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YA sequence of edges taking [3Xf0[103X to [3Xf1[103X.[133X
  
  [33X[0;0YDeclareOperation("DelaunayTriangulation",                         [IsList]);
  DeclareOperation("DelaunayTriangulation", [IsList, IsFloat]);[133X
  
  [1X4.2-3 DelaunayTriangulation[101X
  
  [33X[1;0Y[29X[2XDelaunayTriangulation[102X( [3Xpoints[103X[, [3Xquality[103X] ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YA Delaunay triangulation of the sphere.[133X
  
  [33X[0;0YIf  [3Xpoints[103X  is  a list of points on the unit sphere, represented by their 3D
  coordinates,  this function creates a triangulation of the sphere with these
  points as vertices. This triangulation satisfies the [13XDelaunay[113X condition that
  no point lies in the circumcircle of any face.[133X
  
  [33X[0;0YIf  all  points  are  aligned  on  a great circle, or if all points are in a
  hemisphere, some points are added so as to make the triangulation simplicial
  with  all  edges  of  length [22X<œÄ[122X. These vertices additionally have the [10XIsFake[110X
  property set to [9Xtrue[109X.[133X
  
  [33X[0;0YIf  the  second argument [3Xquality[103X, which must be a floatean, is present, then
  all  triangles  in  the  resulting  triangulation  are  guaranteed  to  have
  circumcircle  ratio  /  minimal  edge  length  at  most  [3Xquality[103X. Of course,
  additional vertices may need to be added to ensure that.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xoctagon := Concatenation(IdentityMat(3),-IdentityMat(3))*1.0;;[127X[104X
    [4X[25Xgap>[125X [27Xdt := DelaunayTriangulation(octagon);[127X[104X
    [4X[28X<triangulation with 6 vertices, 24 edges and 8 faces>[128X[104X
    [4X[25Xgap>[125X [27Xdt!.v;[127X[104X
    [4X[28X[ <vertex 1>, <vertex 2>, <vertex 3>, <vertex 4>, <vertex 5>, <vertex 6> ][128X[104X
    [4X[25Xgap>[125X [27Xlast[1].n;[127X[104X
    [4X[28X[ <edge 17>, <edge 1>, <edge 2>, <edge 11> ][128X[104X
    [4X[25Xgap>[125X [27Xlast[1].from;[127X[104X
    [4X[28X<vertex 1>[128X[104X
  [4X[32X[104X
  
  [33X[0;0YDeclareOperation("AddToTriangulation",   [IsSphereTriangulation,IsP1Point]);
  DeclareOperation("AddToTriangulation",
  [IsSphereTriangulation,IsP1Point,IsBool]);
  DeclareOperation("AddToTriangulation",
  [IsSphereTriangulation,IsTriangulationFace,IsP1Point]);
  DeclareOperation("AddToTriangulation",
  [IsSphereTriangulation,IsTriangulationFace,IsP1Point,IsBool]);[133X
  
  [1X4.2-4 AddToTriangulation[101X
  
  [33X[1;0Y[29X[2XAddToTriangulation[102X( [3Xt[103X[, [3Xseed[103X], [3Xpoint[103X[, [3Xdelaunay[103X] ) [32X operation[133X
  
  [33X[0;0YThis  command adds the P1 point [3Xpoint[103X to the triangulation [3Xt[103X. If a face [3Xseed[103X
  is provided, it will speed up the search for the triangle in which the point
  is  to  be  added.  The  other  optional boolean argument [3Xdelaunay[103X specifies
  whether  the Delaunay condition is to be fulfilled (by flipping diagonals of
  some quadrilaterals made of two neighbouring triangles) after the addition.[133X
  
  [33X[0;0YDeclareOperation("RemoveFromTriangulation",
  [IsSphereTriangulation,IsTriangulationVertex]);[133X
  
  [1X4.2-5 RemoveFromTriangulation[101X
  
  [33X[1;0Y[29X[2XRemoveFromTriangulation[102X( [3Xt[103X, [3Xvertex[103X ) [32X operation[133X
  
  [33X[0;0YThis command removes the vertex [3Xvertex[103X from the triangulation [3Xt[103X.[133X
  
  [33X[0;0YDeclareOperation("LocateFaceInTriangulation",
  [IsSphereTriangulation,IsP1Point]);
  DeclareOperation("LocateFaceInTriangulation",
  [IsSphereTriangulation,IsObject,IsP1Point]);
  DeclareOperation("LocateInTriangulation",
  [IsSphereTriangulation,IsP1Point]);
  DeclareOperation("LocateInTriangulation",
  [IsSphereTriangulation,IsObject,IsP1Point]);[133X
  
  [1X4.2-6 LocateFaceInTriangulation[101X
  
  [33X[1;0Y[29X[2XLocateFaceInTriangulation[102X( [3Xt[103X[, [3Xseed[103X], [3Xpoint[103X ) [32X operation[133X
  [33X[1;0Y[29X[2XLocateInTriangulation[102X( [3Xt[103X[, [3Xseed[103X], [3Xpoint[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YThe face(t) in [3Xt[103X containing [3Xpoint[103X.[133X
  
  [33X[0;0YThis  command locates the face in [3Xt[103X that contains [3Xpoint[103X; in the second form,
  if [3Xpoint[103X lies on an edge or a vertex, it returns that edge or vertex.[133X
  
  [33X[0;0YThe  optional  second  argument  specifies a starting vertex, edge, face, or
  vertex  index from which to start the search. Its only effect is to speed up
  the algorithm.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xcube := Tuples([-1,1],3)/Sqrt(3.0);;[127X[104X
    [4X[25Xgap>[125X [27Xdt := DelaunayTriangulation(cube);[127X[104X
    [4X[28X<triangulation with 8 vertices, 36 edges and 12 faces>[128X[104X
    [4X[25Xgap>[125X [27XLocateInTriangulation(dt,dt!.v[1].pos);[127X[104X
    [4X[28X<vertex 1>[128X[104X
    [4X[25Xgap>[125X [27XLocateInTriangulation(dt,[3/5,0,4/5]*1.0);[127X[104X
    [4X[28X<face 9>[128X[104X
  [4X[32X[104X
  
  [33X[0;0YDeclareOperation("WiggledTriangulation", [IsSphereTriangulation,IsObject]);[133X
  
  [1X4.2-7 WiggledTriangulation[101X
  
  [33X[1;0Y[29X[2XWiggledTriangulation[102X( [3Xt[103X, [3Xmoebiusmap[103X ) [32X operation[133X
  [33X[1;0Y[29X[2XWiggledTriangulation[102X( [3Xt[103X, [3Xnewpoints[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YA new triangulation, with moved vertices.[133X
  
  [33X[0;0YThis  command  creates a new triangulation, in which only the P1 coordinates
  are  changed.  If the second argument [3Xmoebiusmap[103X is a M√∂bius transformation,
  then  it  is  applied to the vertices and barycentres of faces and edges. If
  the second argument [3Xnewpoints[103X is a list of P1 points, then they are taken as
  new coordinates of the vertices.[133X
  
  [33X[0;0YDeclareGlobalFunction("EquidistributedP1Points");[133X
  
  [1X4.2-8 EquidistributedP1Points[101X
  
  [33X[1;0Y[29X[2XEquidistributedP1Points[102X( [3XN[103X ) [32X function[133X
  [6XReturns:[106X  [33X[0;10YA list of [3XN[103X P1 points that are reasonably well spaced.[133X
  
  
  [1X4.3 [33X[0;0YMarked spheres[133X[101X
  
  [33X[0;0YMarked  spheres  should  be  thought of as punctured complex spheres, with a
  explicit identification of a sphere group with their fundamental group. They
  model points in Teichm√ºller space.[133X
  
  [33X[0;0YMarked  spheres  are  given  by  a  triangulation  and  a sphere group whose
  generators  are  in bijection with the triangulation's vertices. Internally,
  the  marked  sphere  keeps  track of a group element at each edge, stored as
  [10XGroupElement(e)[110X.  This  is the group element by which one should multiply as
  the  edge  is crossed transversally. In particular, the product of the edges
  going out of vertex [22Xv[122X is conjugate to generator number [22Xv[122X.[133X
  
  [33X[0;0YGiven  a  marked  sphere  and  a  rational  map  (given  by coefficients), a
  procedure computes the "lifted marked sphere" and a wreath recursion between
  their  respective  groups,  i.e.  a  homomorphism  [22XG_0  -> G_1 ‚âÄ Sym(d)[122X. The
  procedure  will  probably  fail  unless the critical values are close to the
  feet.  There,  the  algorithm is already subtle: edges of the dual graph are
  represented by arcs of great circles.[133X
  
  [33X[0;0YOne  first  computes  the  full  preimage  of  the feet, and a triangulation
  spanning them on a sphere "above" the original marked sphere. Then, for each
  edge  of  the  "down"  dual  graph,  its  preimage  on the "up" sphere is an
  algebraic  curve.  One computes its intersections with all edges of the "up"
  dual  graph,  by finding zeroes of real polynomials, to determine from which
  triangle to which one the lifted edges go.[133X
  
  [33X[0;0YBecause  of  rounding  errors,  one  has  to  be  careful  as to when a real
  polynomial  is supposed to have a zero, or when a point is supposed to be in
  a  triangle.  E.g.,  if  [22XT[122X  is a triangle and its sides are given by arcs of
  great  circles, represented as [22XŒ≥_i([0,1])[122X for M√∂bius maps [22XŒ≥_i, i=1,2,3[122X, then
  the  test [22X‚Ñë(Œ≥_i(z))>0 ‚àÄ i[122X determines whether [22Xz[122X is in the triangle. This test
  is  really coded as [22X‚Ñë(Œ≥_i(z)) / (1+|Œ≥_i(z)|^2) > -@IMG.p1eps[122X to take care of
  rounding      errors.      DeclareCategory("IsMarkedSphere",      IsObject);
  BindGlobal("MARKEDSPHERES_FAMILY",                NewFamily("MarkedSpheres",
  IsMarkedSphere));                            BindGlobal("TYPE_MARKEDSPHERE",
  NewType(MARKEDSPHERES_FAMILY,                              IsMarkedSphere));
  DeclareAttribute("MarkedSphere",                           IsSphereMachine);
  DeclareAttribute("MarkedSphere",     IsP1Map);    undocumented    for    now
  DeclareAttribute("VerticesOfMarkedSphere",                  IsMarkedSphere);
  DeclareAttribute("SpanningTreeBoundary", IsMarkedSphere);[133X
  
  [1X4.3-1 IsMarkedSphere[101X
  
  [33X[1;0Y[29X[2XIsMarkedSphere[102X[32X filter[133X
  
  [33X[0;0YThe category of marked, triangulated spheres (points in Teichm√ºller space).[133X
  
  [33X[0;0YDeclareOperation("NewMarkedSphere",    [IsP1PointCollection,IsSphereGroup]);
  DeclareOperation("NewMarkedSphere", [IsP1PointCollection]);[133X
  
  [1X4.3-2 NewMarkedSphere[101X
  
  [33X[1;0Y[29X[2XNewMarkedSphere[102X( [3Xpoints[103X[, [3Xgroup[103X] ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YA new marked sphere on points [3Xpoints[103X.[133X
  
  [33X[0;0YThis   function   creates  a  new  marked  sphere,  based  on  the  Delaunay
  triangulation on [3Xpoints[103X. If a sphere group [3Xgroup[103X is specified, it is used to
  mark the sphere; otherwise a new sphere group is created.[133X
  
  [33X[0;0YDeclareOperation("Draw", [IsMarkedSphere]);[133X
  
  [1X4.3-3 Draw[101X
  
  [33X[1;0Y[29X[2XDraw[102X( [3Xs[103X ) [32X operation[133X
  
  [33X[0;0YThis command plots the marked sphere [3Xs[103X in a separate window. It displays the
  complex  sphere, big dots at the post-critical set (feet of the spider), and
  the arcs and dual arcs of the triangulation connecting the feet.[133X
  
  [33X[0;0YIf  the option [9Xjulia:=<gridsize>[109X (if no grid size is specified, it is 500 by
  default),  then  the Julia set of the map associated with the spider is also
  displayed.  Points  attracted  to  attracting  cycles are coloured in pastel
  tones, and unattracted points are coloured black.[133X
  
  [33X[0;0YIf the option [9Xnoarcs[109X is specified, the printing of the arcs and dual arcs is
  disabled.[133X
  
  [33X[0;0YThe options [9Xupper[109X, [9Xlower[109X and [9Xdetach[109X also apply.[133X
  
  [33X[0;0YDeclareOperation("WiggledMarkedSphere", [IsMarkedSphere,IsObject]);[133X
  
  [1X4.3-4 WiggledMarkedSphere[101X
  
  [33X[1;0Y[29X[2XWiggledMarkedSphere[102X( [3Xsphere[103X, [3Xm[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YA new marked sphere.[133X
  
  [33X[0;0YThis  operation  moves  the vertices of the marked sphere [3Xsphere[103X, preserving
  its  marking. The argument [3Xm[103X, which specifies a movement of the vertices, is
  either  a M√∂bius transformation (to be applied to all vertices) or a list of
  new positions for them.[133X
  
  [33X[0;0YDeclareOperation("SphereMachineOfBranchedCovering",
  [IsMarkedSphere,IsMarkedSphere,IsP1Map,IsBool]);
  DeclareOperation("SphereMachineOfBranchedCovering",
  [IsMarkedSphere,IsMarkedSphere,IsP1Map]);
  DeclareOperation("SphereMachineAndSphereOfBranchedCovering",
  [IsMarkedSphere,IsP1Map,IsBool]);
  DeclareOperation("SphereMachineAndSphereOfBranchedCovering",
  [IsMarkedSphere,IsP1Map]);[133X
  
  [1X4.3-5 SphereMachineOfBranchedCovering[101X
  
  [33X[1;0Y[29X[2XSphereMachineOfBranchedCovering[102X( [3Xdown[103X, [3Xup[103X, [3Xmap[103X[, [3Xpoly[103X] ) [32X operation[133X
  [33X[1;0Y[29X[2XSphereMachineAndSphereOfBranchedCovering[102X( [3Xdown[103X, [3Xmap[103X[, [3Xpoly[103X] ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YA sphere machine or [machine,marked sphere].[133X
  
  [33X[0;0YThe first function computes, out of a marked sphere [3Xdown[103X in the range of the
  P1  map  [3Xmap[103X  and  a  marked  sphere  [3Xup[103X  in  its domain, the sphere machine
  representing  the  monodromy  action  of  the map. Its input stateset is the
  model group of [3Xdown[103X, while its output stateset is the model group of [3Xup[103X.[133X
  
  [33X[0;0YThe  second  function first computes a marked sphere on the full preimage by
  [3Xmap[103X  of  the vertices of [3Xdown[103X, then computes the sphere machine, and finally
  returns a list containing the machine and the sphere at the source of [3Xmap[103X.[133X
  
  [33X[0;0YThe optional parameter [3Xpoly[103X specifies that the map [3Xmap[103X is to be treated as a
  polynomial,  and  that  the  machine  is  to  be normalized so that its last
  generator is an adding machine in standard form.[133X
  
  [33X[0;0YDeclareOperation("MonodromyOfP1Map",              [IsMarkedSphere,IsP1Map]);
  DeclareOperation("MonodromyOfP1Map",         [IsP1PointCollection,IsP1Map]);
  DeclareOperation("MonodromyOfP1Map", [IsP1Map]);[133X
  
  [1X4.3-6 MonodromyOfP1Map[101X
  
  [33X[1;0Y[29X[2XMonodromyOfP1Map[102X( [[3Xmarking[103X, ][3Xmap[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YThe monodromy action of [3Xmap[103X.[133X
  
  [33X[0;0YThis  function  computes the monodromy of the P1 map [3Xmap[103X; this is simply the
  activity of the sphere machine associated with the map.[133X
  
  [33X[0;0YThe  optional  first  argument [3Xmarking[103X may be a marked sphere, in which case
  the  monodromy  is  returned  as  a  homomorphism  from  the marked sphere's
  marking.  It may also be a list of P1 points, in which case the monodromy is
  returned  as a list of permutations, one per point. If the first argument is
  missing, it is assumed to be the list of critical values of [3Xmap[103X.[133X
  
  [33X[0;0YDeclareAttribute("SphereMachine", IsP1Map);[133X
  
  [1X4.3-7 SphereMachine[101X
  
  [33X[1;0Y[29X[2XSphereMachine[102X( [3Xf[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YA sphere machine.[133X
  
  [33X[0;0YThis  function  computes a triangulation of the sphere, on the post-critical
  set  of  [3Xf[103X,  and  lifts  it through the map [3Xf[103X. the action of the fundamental
  group  of  the punctured sphere is then read into an sphere machine [10Xm[110X, which
  is returned.[133X
  
  [33X[0;0YThis machine has a preset attribute [10XMarkedSphere(m)[110X.[133X
  
  [33X[0;0YAn  approximation  of the Julia set of [3Xf[103X can be computed, and plotted on the
  spider,       with       the       form       [10XSphereMachine(f:julia)[110X      or
  [10XSphereMachine(f:julia:=gridsize)[110X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XSphereMachine(P1z^2-1);[127X[104X
    [4X[28X<FR machine with alphabet [ 1, 2 ] on Group( [ f1, f2, f3 ] )/[ f2*f1*f3 ]>[128X[104X
    [4X[25Xgap>[125X [27XDisplay(last);[127X[104X
    [4X[28X G  |            1        2[128X[104X
    [4X[28X----+---------------+--------+[128X[104X
    [4X[28X f1 |          f2,2   <id>,1[128X[104X
    [4X[28X f2 | f3^-1*f1*f3,1   <id>,2[128X[104X
    [4X[28X f3 |        <id>,2     f3,1[128X[104X
    [4X[28X----+---------------+--------+[128X[104X
    [4X[28XRelator: f2*f1*f3[128X[104X
  [4X[32X[104X
  
  [33X[0;0YDeclareOperation("DistanceMarkedSpheres", [IsMarkedSphere, IsMarkedSphere]);
  DeclareOperation("DistanceMarkedSpheres",  [IsMarkedSphere,  IsMarkedSphere,
  IsBool]);[133X
  
  [1X4.3-8 DistanceMarkedSpheres[101X
  
  [33X[1;0Y[29X[2XDistanceMarkedSpheres[102X( [3Xsphere1[103X, [3Xsphere2[103X[, [3Xfast[103X] ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YThe approximate distance between the marked spheres.[133X
  
  [33X[0;0YThis  function approximates coarsely the Teichm√ºller distance between marked
  spheres  with same model group. If the vertices of [3Xsphere1[103X can be wiggled to
  the  vertices  of  [3Xsphere2[103X in such a manner that the markings coincide, then
  the  distance  is the sum of the movements of the vertices. Otherwise, it is
  [22X1+[122X  the sum of the lengths of the images of a sphere group automorphism that
  carries the marking of [3Xsphere1[103X to that of [3Xsphere2[103X.[133X
  
  
  [1X4.4 [33X[0;0YThe Hurwitz problem[133X[101X
  
  [33X[0;0YGiven  a  marked  sphere  and  a  permutation representation of its group, a
  procedure computes a rational map with that monodromy. If the representation
  has  degree  [22X2[122X, or is bicritical, or a few other cases easily coded by hand,
  then the rational map is computed algebraically.[133X
  
  [33X[0;0YOtherwise,  the "hard" part of the algorithm comes into play. A fresh marked
  sphere  is  constructed with only the feet with non-trivial permutation. The
  triangulation   is   then  combinatorially  lifted,  using  the  permutation
  representation.  In  particular,  the  feet are now labeled by cycles of the
  permutations. It is a purely combinatorial triangulation, at this point; but
  one remembers that its edges have a length inherited from the sphere metric.
  The  triangulation  is  then  refined  by repeatedly adding circumcentres of
  triangles,  till every edge (say from [22Xv[122X to [22Xw[122X) has length [22Xle @IMG.hurwitzmesh
  ^ Maximum(cycle length at v, cycle length at w)[122X.[133X
  
  [33X[0;0YNow  an  external  C  program,  "layout",  is  called.  It  seeks a discrete
  conformal map, given by a function [22Xu: {feet} -> R[122X, such that if edge [22Xe[122X (from
  [22Xv[122X  to  [22Xw[122X)  has  its  length  scaled  by [22Xu(v)‚ãÖ u(w)[122X then the sum-of-angles=2[22XœÄ[122X
  condition  holds  at  each  vertex  (with  special treatment for a vertex at
  infinity;  I  skip  details).  Then the triangulation can be laid out on the
  plane,  and  projected back stereographically to the sphere. In this manner,
  we got good approximations of where the feet should be.[133X
  
  [33X[0;0YNow  we  run  Newton's  method on the feet positions, using as variables the
  lifted-feet  positions. This is the external program "hsolve". It is assumed
  that  the down-feet contain [22X0[122X and [22X‚àû[122X, so that the rational map we are looking
  for is of the form [22Xf(z) = C‚ãÖ‚àè(z-c_i)^d_i[122X for known integers [22Xd_i[122X. The [22Xc_i[122X are
  the lifted-feet above [22X0[122X and [22X‚àû[122X, and the equations in Newton's method say that
  the  log-derivative  of [22Xf[122X must vanish at appropriate lifted-feet, and that [22Xf[122X
  must       map       these      lifted-feet      to      the      down-feet.
  DeclareOperation("BranchedCoveringByMonodromy",
  [IsMarkedSphere,IsGroupHomomorphism]);
  DeclareOperation("BranchedCoveringByMonodromy",
  [IsMarkedSphere,IsGroupHomomorphism,IsRecord]);[133X
  
  [1X4.4-1 BranchedCoveringByMonodromy[101X
  
  [33X[1;0Y[29X[2XBranchedCoveringByMonodromy[102X( [3Xsphere[103X, [3Xmonodromy[103X[, [3Xlast[103X] ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YA record describing a Hurwitz map.[133X
  
  [33X[0;0YIf  [3Xsphere[103X  is  a  marked  sphere,  marked  by a group [22XG[122X, and [3Xmonodromy[103X is a
  homomorphism  from  [22XG[122X  to  a  permutation  group,  this  function computes a
  rational  map  whose  critical  values  are the vertices of [3Xsphere[103X and whose
  monodromy about these critical values is given by [3Xmonodromy[103X.[133X
  
  [33X[0;0YThe  returned  data  are  in a record with a field [10Xdegree[110X, the degree of the
  map;  two  fields [10Xmap[110X and [10Xpost[110X, describing the desired [22XP^1[122X-map --- [10Xpost[110X is a
  M√∂bius  transformation,  and  the composition of [10Xmap[110X and [10Xpost[110X is the desired
  map;  and lists [10Xzeros[110X, [10Xpoles[110X and [10Xcp[110X describing the zeros, poles and critical
  points  of  the  map.  Each  entry  in  these lists is a record with entries
  [10Xdegree[110X,  [10Xpos[110X  and  [10Xto[110X giving, for each point in the source of [10Xmap[110X, the local
  degree and the vertex in [3Xsphere[103X it maps to.[133X
  
  [33X[0;0YIf a third argument is supplied, it should be a record similar to the return
  value  of the command. If the result is close enough to the supplied record,
  it will be used to speed up the calculation.[133X
  
  [33X[0;0YThis  function  requires  external programs in the subdirectory "hurwitz" to
  have been compiled.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27X# we'll construct 2d-2 points on the equator, and permutations[127X[104X
    [4X[25Xgap>[125X [27X# in order (1,2),...,(d-1,d),(d-1,d),...,(1,2) for these points.[127X[104X
    [4X[25Xgap>[125X [27X# first, the marked sphere[127X[104X
    [4X[25Xgap>[125X [27Xd := 20;;[127X[104X
    [4X[25Xgap>[125X [27Xz := List([0..2*d-3], i->P1Point(Exp(i*PMCOMPLEX.constants.2IPI/(2*d-2))));;[127X[104X
    [4X[25Xgap>[125X [27Xg := SphereGroup(2*d-2);;[127X[104X
    [4X[25Xgap>[125X [27Xsphere := NewMarkedSphere(z,g);;[127X[104X
    [4X[25Xgap>[125X [27X# next, the permutation representation[127X[104X
    [4X[25Xgap>[125X [27Xperms := List([1..d-1],i->(i,i+1));;[127X[104X
    [4X[25Xgap>[125X [27XAppend(perms,Reversed(perms));[127X[104X
    [4X[25Xgap>[125X [27Xperms := GroupHomomorphismByImages(g,SymmetricGroup(d),GeneratorsOfGroup(g),perms);;[127X[104X
    [4X[25Xgap>[125X [27X# now compute the map[127X[104X
    [4X[25Xgap>[125X [27XBranchedCoveringByMonodromy(sphere,perms);[127X[104X
    [4X[28Xrec( cp := [ rec( degree := 2, pos := <1.0022-0.0099955i>, to := <vertex 19[ 9, 132, 13, 125 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.0022-0.0099939i>, to := <vertex 20[ 136, 128, 129, 11 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.0039-0.0027487i>, to := <vertex 10[ 73, 74, 16, 82 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.0006-0.0027266i>, to := <vertex 29[ 185, 20, 179, 21 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.0045-7.772e-05i>, to := <vertex 9[ 24, 77, 17, 72 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.1739+0.33627i>, to := <vertex 2[ 31, 32, 41, 28 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.0546+0.12276i>, to := <vertex 3[ 37, 38, 33, 46 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.026+0.061128i>, to := <vertex 4[ 43, 39, 52, 45 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.0148+0.03305i>, to := <vertex 5[ 49, 44, 58, 51 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.0098+0.018122i>, to := <vertex 6[ 55, 50, 64, 57 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.0071+0.0093947i>, to := <vertex 7[ 61, 62, 71, 59 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.0055+0.0037559i>, to := <vertex 8[ 67, 68, 63, 69 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.0035-0.0047633i>, to := <vertex 11[ 79, 75, 88, 81 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.0031-0.0062329i>, to := <vertex 12[ 85, 80, 94, 87 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.0029-0.0073311i>, to := <vertex 13[ 91, 86, 100, 93 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.0027-0.008187i>, to := <vertex 14[ 97, 92, 106, 99 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.0026-0.008824i>, to := <vertex 15[ 103, 98, 112, 105 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.0025-0.0092966i>, to := <vertex 16[ 109, 104, 118, 111 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.0024-0.0096345i>, to := <vertex 17[ 115, 110, 124, 117 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.0023-0.0098698i>, to := <vertex 18[ 121, 116, 122, 123 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.0021-0.0098672i>, to := <vertex 21[ 133, 127, 142, 135 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.002-0.0096298i>, to := <vertex 22[ 139, 134, 148, 141 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.002-0.0092884i>, to := <vertex 23[ 145, 140, 154, 147 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.0019-0.0088147i>, to := <vertex 24[ 151, 146, 160, 153 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.0017-0.008166i>, to := <vertex 25[ 157, 152, 166, 159 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.0016-0.0073244i>, to := <vertex 26[ 163, 158, 172, 165 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.0014-0.0061985i>, to := <vertex 27[ 169, 164, 178, 171 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1.0011-0.0047031i>, to := <vertex 28[ 175, 170, 176, 177 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <0.99908+0.0038448i>, to := <vertex 31[ 187, 183, 196, 189 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <0.99759+0.0094326i>, to := <vertex 32[ 193, 188, 202, 195 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <0.99461+0.018114i>, to := <vertex 33[ 199, 194, 208, 201 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <0.98944+0.032796i>, to := <vertex 34[ 205, 200, 214, 207 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <0.9772+0.058259i>, to := <vertex 35[ 211, 206, 220, 213 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <0.94133+0.11243i>, to := <vertex 36[ 217, 212, 226, 219 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <0.79629+0.23807i>, to := <vertex 37[ 223, 224, 225, 221 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <1+0i>, to := <vertex 30[ 181, 182, 6, 190 ]> ) ], degree := 20, [128X[104X
    [4X[28X  map := <((-0.32271060393507572-4.3599244721894763i_z)*z^20+(3.8941736874493795+78.415744809040405\[128X[104X
    [4X[28Xi_z)*z^19+(-16.808157937605603-665.79436908026275i_z)*z^18+(2.6572296014719168+3545.861245383101i_z\[128X[104X
    [4X[28X)*z^17+(316.57668022762243-13273.931613611372i_z)*z^16+(-1801.6631038749117+37090.818733740503i_z)*\[128X[104X
    [4X[28Xz^15+(5888.6033008259928-80172.972599556582i_z)*z^14+(-13500.864941314803+137069.10015838256i_z)*z^\[128X[104X
    [4X[28X13+(23251.436304923012-187900.36507913063i_z)*z^12+(-31048.192131502536+208077.63047409133i_z)*z^11\[128X[104X
    [4X[28X+(32639.349270133433-186578.17493860485i_z)*z^10+(-27155.791223040047+135145.40893002271i_z)*z^9+(1\[128X[104X
    [4X[28X7836.343164500577-78489.005444299968i_z)*z^8+(-9153.842142530224+36053.895961137248i_z)*z^7+(3598.6\[128X[104X
    [4X[28X408777659944-12810.65497539577i_z)*z^6+(-1047.541279063196+3397.470068169695i_z)*z^5+(212.906725643\[128X[104X
    [4X[28X0024-633.29691376653466i_z)*z^4+(-26.989372105307872+74.040615571896637i_z)*z^3+(1.6073346640110264\[128X[104X
    [4X[28X-4.0860733899027055i_z)*z^2)/(z^18+(-18.034645372692019-0.45671993287358581i_z)*z^17+(153.540499397\[128X[104X
    [4X[28X49956+7.7811506405054889i_z)*z^16+(-819.9344323563339-62.384270590463998i_z)*z^15+(3077.71530771320\[128X[104X
    [4X[28X75+312.59552100187739i_z)*z^14+(-8623.1225834872057-1096.4398001099003i_z)*z^13+(18689.34396825033+\[128X[104X
    [4X[28X2856.8568878158458i_z)*z^12+(-32038.568184053798-5725.9186424029094i_z)*z^11+(44038.148375498437+90\[128X[104X
    [4X[28X17.0162876593004i_z)*z^10+(-48898.555649389084-11295.156285052604i_z)*z^9+(43964.579894637543+11318\[128X[104X
    [4X[28X.997395732025i_z)*z^8+(-31931.403449371515-9074.2344933443364i_z)*z^7+(18595.347261301522+5786.6036\[128X[104X
    [4X[28X424805825i_z)*z^6+(-8565.0823844971637-2899.3353634270734i_z)*z^5+(3051.6919509143086+1117.44496422\[128X[104X
    [4X[28X99487i_z)*z^4+(-811.56293104533825-319.93036282549667i_z)*z^3+(151.69784956523344+64.11787684283315\[128X[104X
    [4X[28X5i_z)*z^2+(-17.785127700028404-8.0311759305108268i_z)*z+(0.98427999507354302+0.47338721325094818i_z\[128X[104X
    [4X[28X))>, poles := [ rec( degree := 1, pos := <0.99517+0.30343i>, to := <vertex 1[ 26, 27, 1, 34 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0021+0.11512i>, to := <vertex 1[ 26, 27, 1, 34 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0028+0.05702i>, to := <vertex 1[ 26, 27, 1, 34 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0026+0.030964i>, to := <vertex 1[ 26, 27, 1, 34 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0025+0.016951i>, to := <vertex 1[ 26, 27, 1, 34 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0024+0.0085784i>, to := <vertex 1[ 26, 27, 1, 34 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0024+0.003208i>, to := <vertex 1[ 26, 27, 1, 34 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0023-0.00046905i>, to := <vertex 1[ 26, 27, 1, 34 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0023-0.0030802i>, to := <vertex 1[ 26, 27, 1, 34 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0023-0.0049913i>, to := <vertex 1[ 26, 27, 1, 34 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0023-0.0064163i>, to := <vertex 1[ 26, 27, 1, 34 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0022-0.0074855i>, to := <vertex 1[ 26, 27, 1, 34 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0022-0.0082954i>, to := <vertex 1[ 26, 27, 1, 34 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0022-0.0089048i>, to := <vertex 1[ 26, 27, 1, 34 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0022-0.0093543i>, to := <vertex 1[ 26, 27, 1, 34 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0022-0.0096742i>, to := <vertex 1[ 26, 27, 1, 34 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0022-0.0098869i>, to := <vertex 1[ 26, 27, 1, 34 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0022-0.0099988i>, to := <vertex 1[ 26, 27, 1, 34 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <P1infinity>, to := <vertex 1[ 26, 27, 1, 34 ]> ) ], [128X[104X
    [4X[28X  post := <((-0.91742065452766763+0.99658449300666985i_z)*z+(0.74087581626192234-1.1339948562200648\[128X[104X
    [4X[28Xi_z))/((-0.75451451285920013+0.96940026593933015i_z)*z+(0.75451451285920013-0.96940026593933015i_z)\[128X[104X
    [4X[28X)>, zeros := [ rec( degree := 1, pos := <0.92957+0.28362i>, to := <vertex 38[ 30, 3, 228, 7 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <0.99173+0.11408i>, to := <vertex 38[ 30, 3, 228, 7 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <0.99985+0.056874i>, to := <vertex 38[ 30, 3, 228, 7 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0014+0.030945i>, to := <vertex 38[ 30, 3, 228, 7 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.002+0.016938i>, to := <vertex 38[ 30, 3, 228, 7 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0022+0.0085785i>, to := <vertex 38[ 30, 3, 228, 7 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0022+0.0032076i>, to := <vertex 38[ 30, 3, 228, 7 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0022-0.00046827i>, to := <vertex 38[ 30, 3, 228, 7 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0022-0.0030802i>, to := <vertex 38[ 30, 3, 228, 7 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0022-0.0049908i>, to := <vertex 38[ 30, 3, 228, 7 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0022-0.006416i>, to := <vertex 38[ 30, 3, 228, 7 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0022-0.0074855i>, to := <vertex 38[ 30, 3, 228, 7 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0022-0.0082953i>, to := <vertex 38[ 30, 3, 228, 7 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0022-0.0089047i>, to := <vertex 38[ 30, 3, 228, 7 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0022-0.0093542i>, to := <vertex 38[ 30, 3, 228, 7 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0022-0.0096742i>, to := <vertex 38[ 30, 3, 228, 7 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0022-0.0098869i>, to := <vertex 38[ 30, 3, 228, 7 ]> ), [128X[104X
    [4X[28X      rec( degree := 1, pos := <1.0022-0.0099988i>, to := <vertex 38[ 30, 3, 228, 7 ]> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <0+0i>, to := <vertex 38[ 30, 3, 228, 7 ]> ) ] )[128X[104X
  [4X[32X[104X
  
  [33X[0;0YDeclareOperation("DessinByPermutations",                   [IsPerm,IsPerm]);
  DeclareOperation("DessinByPermutations", [IsPerm,IsPerm,IsPerm]);[133X
  
  [1X4.4-2 DessinByPermutations[101X
  
  [33X[1;0Y[29X[2XDessinByPermutations[102X( [3Xs0[103X, [3Xs1[103X[, [3Xsinf[103X] ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YA  rational  map  (see  [2XBranchedCoveringByMonodromy[102X  ([14X4.4-1[114X)) with
            monodromies [3Xs,t[103X.[133X
  
  [33X[0;0YThis  command  computes  the  Hurwitz  map associated with the spanning tree
  [22X[0,1]‚à™[1,‚àû][122X;  the monodromy representation is by the permutation [3Xs0[103X at [22X0[122X and
  [3Xs1[103X  at  [22X1[122X.  The optional third argument [3Xsinf[103X is the monodromy at [22X‚àû[122X, and must
  equal [22Xs_0^-1s_1^-1[122X.[133X
  
  [33X[0;0YThe  data is returned as a record, with entries [10Xdegree[110X, [10Xmap[110X, [10Xpost[110X, and lists
  [10Xpoles[110X,  [10Xzeros[110X,  and  [10Xabove1[110X. Each entry in the list is a record with entries
  [10Xpos[110X and [10Xdegree[110X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XDessinByPermutations((1,2),(2,3));[127X[104X
    [4X[28Xrec( above1 := [ rec( degree := 2, pos := <1+0i> ),[128X[104X
    [4X[28X                 rec( degree := 1, pos := <-0.5-1.808e-14i> ) ],[128X[104X
    [4X[28X     degree := 3, [128X[104X
    [4X[28X     map := <(-1.9999999999946754+2.1696575743432764e-13i_z)*z^3+(2.9999999999946754-2.1696575743432764e-13i_z)*z^2>,[128X[104X
    [4X[28X     poles := [ rec( degree := 3, pos := <P1infinity> ) ],[128X[104X
    [4X[28X     post := <z>, [128X[104X
    [4X[28X     zeros := [ rec( degree := 1, pos := <1.5+5.4241e-14i> ),[128X[104X
    [4X[28X                rec( degree := 2, pos := <0+0i> ) ] )[128X[104X
    [4X[25Xgap>[125X [27X# the Cui example[127X[104X
    [4X[25Xgap>[125X [27XDessinByPermutations((1,3,12,4)(5,9)(6,7)(10,13,11)(2,8),[127X[104X
    [4X[28X           (1,5,13,6)(7,10)(2,3)(8,11,12)(4,9),[128X[104X
    [4X[28X           (1,7,11,2)(3,8)(4,5)(9,12,13)(6,10));[128X[104X
    [4X[28Xrec( [128X[104X
    [4X[28X  above1 := [ rec( degree := 2, pos := <1.9952-0.79619i> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <0.43236-0.17254i> ), rec( degree := 2, pos := <-0.9863-0.16498i> ),[128X[104X
    [4X[28X      rec( degree := 3, pos := <-0.12749-0.99184i> ), rec( degree := 4, pos := <1+0i> ) ], [128X[104X
    [4X[28X  degree := 13, [128X[104X
    [4X[28X  map := <((-6.9809917616400366e-12+0.13002709490708636i_z)*z^13+(-0.68172329304137969-0.8451761169\[128X[104X
    [4X[28X2062078i_z)*z^12+(4.0903397584184269+0.30979932084028583i_z)*z^11+(-6.3643009040280925+7.5930410215\[128X[104X
    [4X[28X99336i_z)*z^10+(-5.1732765988942884-16.738910009700096i_z)*z^9+(21.528087032174511+6.11354599010482\[128X[104X
    [4X[28X5i_z)*z^8+(-15.258776392407746+13.657687016998921i_z)*z^7+(-1.6403496019814323-13.453316297094229i_\[128X[104X
    [4X[28Xz)*z^6+(4.4999999996894351+3.3633290741375781i_z)*z^5+(-0.99999999990279009+2.5538451239904557e-11i\[128X[104X
    [4X[28X_z)*z^4)/(z^9+(-4.4999999999400613+3.3633290744267983i_z)*z^8+(1.6403496020557891-13.45331629745540\[128X[104X
    [4X[28X7i_z)*z^7+(15.258776391831654+13.657687016903173i_z)*z^6+(-21.528087030670253+6.1135459892162567i_z\[128X[104X
    [4X[28X)*z^5+(5.1732765986730511-16.738910007513041i_z)*z^4+(6.3643009027133139+7.593041020468557i_z)*z^3+\[128X[104X
    [4X[28X(-4.0903397575324512+0.30979932067785648i_z)*z^2+(0.68172329288354727-0.8451761166966415i_z)*z+(5.0\[128X[104X
    [4X[28X734454343833585e-12+0.13002709487107747i_z))>, [128X[104X
    [4X[28X  poles := [ rec( degree := 2, pos := <1.6127-0.49018i> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <0.5-0.04153i> ), rec( degree := 2, pos := <-0.61269-0.49018i> ), [128X[104X
    [4X[28X      rec( degree := 3, pos := <0.5-0.43985i> ), rec( degree := 4, pos := <P1infinity> ) ], [128X[104X
    [4X[28X  post := <-z+1._z>, [128X[104X
    [4X[28X  zeros := [ rec( degree := 2, pos := <1.9863-0.16498i> ), [128X[104X
    [4X[28X      rec( degree := 3, pos := <1.1275-0.99184i> ), rec( degree := 2, pos := <0.56764-0.17254i> ), [128X[104X
    [4X[28X      rec( degree := 2, pos := <-0.99516-0.79619i> ), rec( degree := 4, pos := <0+0i> ) ] )[128X[104X
  [4X[32X[104X
  
  [33X[0;0Ygap>  #  IV.5.2  in  Granboulan's PhD, the automorphism group of the Mathieu
  group              M_22              gap>              autm22             :=
  Group((1,2,3,4,5,6,7,8,9,10,11)(12,13,14,15,16,17,18,19,20,21,22),
  (1,9,3,2)(4,8,17,21)(5,20,19,6)(12,22,16,13)(7,18)(10,11)(14,15),
  (3,8)(4,20)(6,18)(7,17)(9,11)(13,15)(16,21));;                          gap>
  IsomorphismGroups(DerivedSubgroup(autm22),MathieuGroup(22))<>fail; true gap>
  DessinByPermutations(autm22.1,autm22.2,autm22.3);   ...  gap>  #  IV.5.3  in
  Granboulan's  PhD, the "extraterrestrial" dessin with group M_24 gap> m24_ET
  :=  Group((1,2,3)(4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24),
  (1,7,5)(2,4,23)(3,22,8)(9,21,19)(10,18,12)(13,17,15),
  (1,4)(2,22)(3,7)(5,6)(8,21)(9,18)(10,11)(12,17)(13,14)(15,16)(19,20)(23,24));;
  gap>     IsomorphismGroups(m24_ET,MathieuGroup(24))<>fail;     true     gap>
  @IMG.hurwitzmesh     :=     0.4;;    #    need    finer    precision    gap>
  DessinByPermutations(m24_ET.1,m24_ET.2,m24_ET.3); ...[133X
  
  
  [1X4.5 [33X[0;0YThe spider algorithm[133X[101X
  
  [33X[0;0Y[5XIMG[105X   implements  an  algorith,  extending  the  Thurston-Hubbard-Schleicher
  "spider  algorithm"  [HS94]  that  constructs  a  rational  map  from an IMG
  recursion.  This  implementation does not give rigourous results, but relies
  of  floating-point  approximation.  In  particular,  various  floating-point
  parameters  control the proper functioning of the algorithm. They are stored
  in a record, [10XIMG@[110X. Their meaning and default values are:[133X
  
  [8X[10XEPS@fr.mesh := 10^-1[110X[8X[108X
        [33X[0;6YIf  points  on  the unit sphere are that close, the triangulation mesh
        should be refined.[133X
  
  [8X[10XEPS@fr.p1eps := 10^-8[110X[8X[108X
        [33X[0;6YIf  points  on  the  unit  sphere  are that close, they are considered
        equal.[133X
  
  [8X[10XEPS@fr.obst := 10^-1[110X[8X[108X
        [33X[0;6YIf  points  on  the  unit sphere are that close, they are suspected to
        form a Thurston obstruction.[133X
  
  [8X[10XEPS@fr.fast := 10^-1[110X[8X[108X
        [33X[0;6YIf  the  spider moved less than that amount in the last iteration, try
        speeding  up  by  only wiggling the spider's legs, without recomputing
        it.[133X
  
  [8X[10XEPS@fr.ratprec := 10^-8[110X[8X[108X
        [33X[0;6YThe  minimal  acceptable precision on the coefficients of the rational
        function.[133X
  
  [33X[0;0YFor  Thurston's algorithm, one starts by an arbitrary marked sphere (I chose
  its  feet  on the real axis, at equal small angles); computes a rational map
  using [2XBranchedCoveringByMonodromy[102X ([14X4.4-1[114X), computes its sphere machine using
  [2XSphereMachineOfBranchedCovering[102X  ([14X4.3-5[114X),  and  matches  the original sphere
  machine  with  the lifted one. This tells us which feet of the lifted marked
  sphere we should keep.[133X
  
  [33X[0;0YOne  then computes a normalized position for the sub-marked sphere: its last
  foot  is  put  at  [22X‚àû[122X,  another one (chosen cleverly) is on the positive real
  axis,  and  the center of mass of all feet (in [22XR^3[122X) is [22X(0,0,0)[122X. This is much
  more  stable,  numerically,  than  putting  three points at [22X0,1,‚àû[122X. One has a
  M√∂bius   transformation  that  puts  the  sub-marked  sphere  in  normalized
  position,   and  again  using  [2XSphereMachineOfBranchedCovering[102X  ([14X4.3-5[114X)  one
  computes  its  machine.  One  then  composes  the machines, and compares the
  product  again to the original machine to determine the marking of the edges
  of the new marked sphere by group elements.[133X
  
  [33X[0;0YThen,  one  searches for all quadruples with large cross-ratio, and computes
  group-theoretically  the curve separating the post-critical set in two parts
  that are well separated. One saturates the resulting curve into an invariant
  multicurve  (aborting  if  there is an intersection between lifts), computes
  the  Thurston  matrix,  and  finds  out (again algebraically) if there is an
  eigenvalue  [22X‚â•  1[122X.  There  is  no  parameter  in  this  part of the code, all
  quadruples  are  examined; this is a weakness of the current implementation,
  sometimes  most  of  the  computational  time  is  spent  on  searching  for
  obstructions when it's "clear" there are none.[133X
  
  [33X[0;0YThe  distance  between  two  marked  spheres  (marked  by the same group) is
  computed  as  follows:  if their feet are close in the sense that the sum of
  the spherical distances between them is less that [10X@IMG.fast[110X, then wiggle one
  of  the spiders to make its feet match that of the other; and check that the
  identity map gives, by [2XSphereMachineOfBranchedCovering[102X ([14X4.3-5[114X), the identity
  machine. In that case, the sum of the feet distances is the distance between
  the  spheres. Otherwise, add to it some formula involving the entries in the
  biset, which gives large integer distances.[133X
  
  [33X[0;0YThe Thurston algorithm stops when an obstruction is found or when the marked
  sphere  moved  less  than  [10X@IMG.ratprec[110X.  Inside  the  main iteration of the
  algorithm,  if  the spider moved less that [10X@IMG.fast[110X, then don't compute the
  branched  covering  by  monodromy,  and  don't  compute the bisets; but just
  adjust  the  branched  covering  and  the  vertex  positions of the spheres,
  guessing  which ones should be kept. Check the guess: if it is incorrect, go
  back  to  the  usual  slow method. DeclareGlobalFunction("NormalizedP1Map");
  DeclareProperty("IsBicritical", IsObject);[133X
  
  [1X4.5-1 NormalizedP1Map[101X
  
  [33X[1;0Y[29X[2XNormalizedP1Map[102X( [3Xf[103X, [3XM[103X, [3Xparam[103X ) [32X function[133X
  [6XReturns:[106X  [33X[0;10Y[A canonical conjugate of [3Xf[103X,the conjugator].[133X
  
  [33X[0;0YThe  last  argument [3Xparam[103X is either [10XIsPolynomial[110X, [10XIsBicritical[110X or a positive
  integer.[133X
  
  [33X[0;0YIn  the  first  case,  the map [3Xf[103X is assumed conjugate to a polynomial. It is
  conjugated  by  a M√∂bius transformation that makes it a [13Xcentered[113X polynomial,
  namely a polynomial of the form [22Xz^d+a_d-2z^d-2+dots+a_0[122X.[133X
  
  [33X[0;0YIn  the  second case, the map [3Xf[103X is assumed to have only two critical values;
  it is normalized as [22X(az^d+b)/(cz^d+e)[122X.[133X
  
  [33X[0;0YIn  the  third case, the map [3Xf[103X is assumed to have degree [22X2[122X; it is normalized
  in the form [22X1+a/z+b/z^2[122X, such that [22X0[122X is on a cycle of length [3Xparam[103X.[133X
  
  [33X[0;0YDeclareOperation("ThurstonAlgorithm", [IsSphereMachine]);[133X
  
  [1X4.5-2 ThurstonAlgorithm[101X
  
  [33X[1;0Y[29X[2XThurstonAlgorithm[102X( [3Xm[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10Yrec(map := f, machine := M, markedsphere := s).[133X
  
  [33X[0;0YThis  command  runs  Thurston's algorithm on the sphere machine [3Xm[103X. It either
  returns a record with the P1 map [10Xf[110X to which the algorithm converged, as well
  as  the  marked  sphere  with [10Xf[110X's post-critical set and a simplified machine
  equivalent to [3Xm[103X; or a record returned by [2XThurstonObstruction[102X ([14X4.5-6[114X).[133X
  
  [33X[0;0YDeclareOperation("SpiderAlgorithm", [IsFRMachine]);[133X
  
  [1X4.5-3 SpiderAlgorithm[101X
  
  [33X[1;0Y[29X[2XSpiderAlgorithm[102X( [3Xm[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10Yrec(...) or [9Xfail[109X.[133X
  
  [33X[0;0YThis  command  runs  a symbolic algorithm on the FR machine [3Xm[103X, attempting to
  interpret it as a polynomial sphere machine. It either returns[133X
  
  [8X[9Xfail[109X[108X
        [33X[0;6Yif [3Xm[103X is not a sphere biset;[133X
  
  [8X[10Xrec(minimal := true, machine, supportingangles, rayperiod, ordering, niter, transformation)[110X[8X[108X
        [33X[0;6Yif  [3Xm[103X  is  a  sphere  biset  with  no  obstruction;  then [10Xmachine[110X is a
        polynomial  sphere machine equivalent to [3Xm[103X, [10Xsupportingangles[110X is a list
        of  supporting  rays  in  the  sense  of  Poirier,  see [2XSupportingRays[102X
        ([14X3.3-2[114X);  [10Xrayperiod[110X gives the periods of the rays, [10Xniter[110X is the number
        of iterations needed to produce the machine, and [10Xtransformation[110X is the
        isomorphism  between  the  fundamental  groups  of  the  old  and  new
        machines;[133X
  
  [8X[10Xrec(minimal := false, machine, submachine, homomorphism, relation, niter, transformation)[110X[8X[108X
        [33X[0;6Yif  [3Xm[103X  is  a  sphere biset with an obstruction; then [10Xsubmachine[110X is the
        submachine  obtained  after  removing  the obstruction a sphere biset,
        [10Xhomomorphism[110X  is  the inclusion of the submachine's stateset into that
        of  [10Xmachine[110X,  [10Xrelation[110X  is  an  equivalence  relation describing which
        points coalesce, and the other parameters are as above.[133X
  
  [33X[0;0YDeclareOperation("P1MapBySphereMachine", [IsSphereMachine]);[133X
  
  [1X4.5-4 P1MapBySphereMachine[101X
  
  [33X[1;0Y[29X[2XP1MapBySphereMachine[102X( [3Xm[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YEither a map or an obstruction.[133X
  
  [33X[0;0YThis  command returs either the map computed by [2XThurstonAlgorithm[102X ([14X4.5-2[114X) or
  a Thurston obstruction.[133X
  
  [33X[0;0YIt runs a modification of Hubbard and Schleicher's "spider algorithm" [HS94]
  on the sphere machine [3Xm[103X.[133X
  
  [33X[0;0YThe  command  accepts  the  following  options,  to  return a map in a given
  normalization:[133X
  
  [8X[10XP1MapBySphereMachine(m:param:=IsPolynomial)[110X[8X[108X
        [33X[0;6Yreturns [22Xf=z^d+A_d-2z^d-2+‚ãØ+A_0[122X;[133X
  
  [8X[10XP1MapBySphereMachine(m:param:=IsBicritical)[110X[8X[108X
        [33X[0;6Yreturns [22Xf=((pz+q)/(rz+s)^d[122X, with [22X1[122Xpostcritical;[133X
  
  [8X[10XP1MapBySphereMachine(m:param:=n)[110X[8X[108X
        [33X[0;6Yreturns [22Xf=1+a/z+b/z^2[122X or [22Xf=a/(z^2+2z)[122X if [10Xn=2[110X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xm := PolynomialSphereMachine(2,[1/3],[]);[127X[104X
    [4X[28X<FR machine with alphabet [ 1, 2 ] on Group( [ f1, f2, f3 ] )/[ f3*f2*f1 ]>[128X[104X
    [4X[25Xgap>[125X [27XP1MapBySphereMachine(m);[127X[104X
    [4X[28X0.866025*z^2+(-1)*z+(-0.288675)[128X[104X
  [4X[32X[104X
  
  [33X[0;0YDeclareOperation("ThurstonMatrix", [IsSphereMachine,IsMulticurve]);[133X
  
  [1X4.5-5 ThurstonMatrix[101X
  
  [33X[1;0Y[29X[2XThurstonMatrix[102X( [3Xm[103X, [3Xmulticurve[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YThe transition matrix of the multicurve.[133X
  
  [33X[0;0YThis  command  computes  the iterated preimages of the multicurve [3Xmulticurve[103X
  till   it   obtains  a  backwards-invariant  multicurve  or  some  preimages
  intersect.  In  the latter case, [9Xfail[109X returned, while in the former case the
  Thurston matrix of the multicurve is returned.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xr := PolynomialSphereMachine(2,[],[1/6]);;[127X[104X
    [4X[25Xgap>[125X [27XF := StateSet(r);;[127X[104X
    [4X[25Xgap>[125X [27Xtwist := GroupHomomorphismByImages(F,F,GeneratorsOfGroup(F),[F.1,F.2^(F.3*F.2),F.3^F.2,F.4]);;[127X[104X
    [4X[25Xgap>[125X [27XSupportingRays(r*twist^-1);[127X[104X
    [4X[28Xrec( machine := <FR machine with alphabet [ 1, 2 ] on F/[ f4*f1*f2*f3 ]>,[128X[104X
    [4X[28X     twist := [ f1, f2, f3, f4 ] -> [ f1, f3^-1*f2*f3, f3^-1*f2^-1*f3*f2*f3, f4 ],[128X[104X
    [4X[28X     obstruction := "Dehn twist" )[128X[104X
    [4X[25Xgap>[125X [27XThurstonMatrix(last.machine,[ConjugacyClass(F.2*F.3)]);[127X[104X
    [4X[28X[ [ 1 ] ][128X[104X
  [4X[32X[104X
  
  [33X[0;0YDeclareOperation("ThurstonObstruction", [IsSphereMachine,IsMarkedSphere]);[133X
  
  [1X4.5-6 ThurstonObstruction[101X
  
  [33X[1;0Y[29X[2XThurstonObstruction[102X( [3Xm[103X, [3Xsphere[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10Yrec(multicurve := mc, matrix := m) or [9Xfail[109X.[133X
  
  [33X[0;0YThis  command tries to find a Thurston obstruction (multicurve such that its
  Thurston  matrix  has spectral radius at least [22X1[122X); it either returns [9Xfail[109X if
  the search was inconclusive, or a record describing the obstruction.[133X
  
  [33X[0;0YThe obstruction is searched for by considering small subtrees of the minimal
  spanning  tree  of  [3Xsphere[103X,  computing loops surrounding these subtrees, and
  saturating  them  into  a multicurve by taking their iterated preimages, see
  [2XThurstonMatrix[102X ([14X4.5-5[114X).[133X
  
