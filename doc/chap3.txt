  
  [1X3 [33X[0;0YSphere groups and machines[133X[101X
  
  
  [1X3.1 [33X[0;0YSphere groups[133X[101X
  
  [33X[0;0YFundamental  groups  of  punctured  spheres,  and  of  sphere orbifolds, are
  defined  in  [5XIMG[105X  as  a  special  class  of  finitely  presented groups. The
  generators  of  the  group  represent  the  punctures of the sphere, or more
  generally its orbispace points.[133X
  
  [1X3.1-1 IsSphereGroup[101X
  
  [33X[1;0Y[29X[2XIsSphereGroup[102X[32X filter[133X
  
  [33X[0;0YA  sphere  group  is  a  special  kind of finitely presented group, in which
  exactly one relation is a product, in some order, of all the generators, and
  all the other relations (possibly none) are powers of generators.[133X
  
  [33X[0;0YSphere  groups  are  used  to  represent the fundamental groups of punctured
  spheres, or more generally orbifolds whose underlying space is a sphere.[133X
  
  [1X3.1-2 IsomorphismSphereGroup[101X
  
  [33X[1;0Y[29X[2XIsomorphismSphereGroup[102X( [3Xg[103X ) [32X attribute[133X
  [33X[1;0Y[29X[2XAsSphereGroup[102X( [3Xg[103X ) [32X attribute[133X
  
  [33X[0;0YThese  functions  compute an isomorphism from [3Xg[103X to a sphere group; the first
  form returns the isomorphism, while the second one returns its image.[133X
  
  [1X3.1-3 EulerCharacteristic[101X
  
  [33X[1;0Y[29X[2XEulerCharacteristic[102X( [3Xg[103X ) [32X attribute[133X
  [6XReturns:[106X  [33X[0;10YThe Euler characteristic of [3Xg[103X.[133X
  
  [33X[0;0YThe Euler characteristic of a free group of rank [22Xn[122X is [22X1-n[122X; and it multiplies
  by the index on subgroups. A sphere group is finite if and only if its Euler
  characteristic  is  positive,  and  is  virtually abelian if and only if its
  Euler characteristic is [22X0[122X.[133X
  
  [1X3.1-4 RankOfSphereGroup[101X
  
  [33X[1;0Y[29X[2XRankOfSphereGroup[102X( [3Xg[103X ) [32X attribute[133X
  [6XReturns:[106X  [33X[0;10YThe number of generators of [3Xg[103X.[133X
  
  [1X3.1-5 OrderingOfSphereGroup[101X
  
  [33X[1;0Y[29X[2XOrderingOfSphereGroup[102X( [3Xg[103X ) [32X attribute[133X
  [6XReturns:[106X  [33X[0;10YThe list of the orders of the generators.[133X
  
  [33X[0;0YThis         attribute         has         the         property         that
  [10XProduct(GeneratorsOfGroup(g){OrderingOfSphereGroup(g)})[110X is the identity.[133X
  
  [1X3.1-6 ExponentsOfSphereGroup[101X
  
  [33X[1;0Y[29X[2XExponentsOfSphereGroup[102X( [3Xg[103X ) [32X attribute[133X
  [6XReturns:[106X  [33X[0;10YThe list of exponents of the generators.[133X
  
  [33X[0;0YThis         attribute         has         the         property         that
  [10XGeneratorsOfGroup(g)[i]^ExponentsOfSphereGroup(g)[i][110X is the identity for all
  [10Xi[110X. If an element has infinite order, the value stored is [10X0[110X.[133X
  
  [1X3.1-7 IsomorphismFreeGroup[101X
  
  [33X[1;0Y[29X[2XIsomorphismFreeGroup[102X( [3Xg[103X ) [32X attribute[133X
  [6XReturns:[106X  [33X[0;10YAn isomorphism to a free group, if it exists.[133X
  
  [33X[0;0YIf  [3Xg[103X  was  created as a sphere group with all exponents infinity, then [3Xg[103X is
  isomorphic  to  a  free  group on all the generators but one; this attribute
  stores such an isomorphism.[133X
  
  [1X3.1-8 SphereGroup[101X
  
  [33X[1;0Y[29X[2XSphereGroup[102X( [3Xordering[103X[, [3Xexponent[103X] ) [32X function[133X
  [6XReturns:[106X  [33X[0;10YA new sphere group.[133X
  
  [33X[0;0Y[3Xordering[103X  is  either  a  list  of  integers,  describing  the  order  of the
  generators  that  is  to  be  trivial;  or  an  integer [10Xm[110X, in which case the
  ordering is [10X[m,m-1,..,1][110X.[133X
  
  [33X[0;0YThe  optional  second argument [3Xexponent[103X is a list of integers describing the
  exponents  of  the generators. The value [10X0[110X specifies a generator of infinite
  order.[133X
  
  [1X3.1-9 IsSphereConjugacyClass[101X
  
  [33X[1;0Y[29X[2XIsSphereConjugacyClass[102X[32X filter[133X
  
  [33X[0;0YElements  of  a  sphere  group  represent based loops on a punctured sphere.
  Loops  (without specified basepoint) are represented by conjugacy classes. A
  [13Xmulticurve[113X is a collection of non-intersecting loops.[133X
  
  [33X[0;0YConjugacy  classes  may  be  raised  to  integer  powers; the [22Xn[122Xth power of a
  conjugacy class is the conjugacy class of the [22Xn[122Xth power of an element.[133X
  
  [1X3.1-10 IsPeripheral[101X
  
  [33X[1;0Y[29X[2XIsPeripheral[102X( [3Xc[103X ) [32X property[133X
  [6XReturns:[106X  [33X[0;10YWhether the conjugacy class [3Xc[103X is peripheral.[133X
  
  [33X[0;0YA  conjugacy  class  is  [13Xperipheral[113X if it contains a generator of the sphere
  group.[133X
  
  [1X3.1-11 PeripheralClasses[101X
  
  [33X[1;0Y[29X[2XPeripheralClasses[102X( [3Xg[103X ) [32X attribute[133X
  [6XReturns:[106X  [33X[0;10YThe peripheral conjugacy classes of [3Xg[103X.[133X
  
  [1X3.1-12 IntersectionNumber[101X
  
  [33X[1;0Y[29X[2XIntersectionNumber[102X( [3Xc[103X, [3Xd[103X ) [32X attribute[133X
  [6XReturns:[106X  [33X[0;10YThe intersection number of the conjugacy classes [3Xc[103X and [3Xd[103X.[133X
  
  [33X[0;0YThe  [13Xgeometric  intersection  number[113X  of  two loops is the minimal number of
  intersections  they  may have. The [13Xself-intersection number[113X of a loop is the
  intersection number of the loop with a small translate.[133X
  
  [1X3.1-13 AutomorphismGroup[101X
  
  [33X[1;0Y[29X[2XAutomorphismGroup[102X( [3Xg[103X ) [32X attribute[133X
  [33X[1;0Y[29X[2XEpimorphismToOut[102X( [3Xa[103X ) [32X attribute[133X
  
  [33X[0;0YThis  function  computes  the [13Xpure[113X automorphism group of the sphere group [3Xg[103X,
  namely  the  group  of  automorphisms  that  preserves  all  the  peripheral
  conjugacy classes (conjugacy classes of generators).[133X
  
  [33X[0;0YThe  attribute  [10XEpimorphismToOut[110X stores an epimorphism from the automorphism
  group to the group of outer automorphisms.[133X
  
  [1X3.1-14 AmalgamateFreeProduct[101X
  
  [33X[1;0Y[29X[2XAmalgamateFreeProduct[102X( [3Xg[103X, [3Xh[103X, [3Xx[103X, [3Xy[103X ) [32X operation[133X
  
  [33X[0;0YThis  function  computes the amalgamated free product of two sphere groups [3Xg[103X
  and [3Xh[103X, along the cyclic subgroups [22XâŸ¨ xâŸ©[122X of [3Xg[103X and [22XâŸ¨ yâŸ©[122X of [3Xh[103X.[133X
  
  [33X[0;0YThe  attribute  [10XEmbeddingsOfAmalgamatedFreeProduct[110X  is a list of length two,
  storing the embeddings of [3Xg[103X and [3Xh[103X respectively into the amalgam.[133X
  
  
  [1X3.2 [33X[0;0YSphere machines[133X[101X
  
  [33X[0;0YSphere  machines  are  simply  group  FR machines (see Section [14Xfr: FRMachine
  [list,]list,list[114X)  whose  underlying [2XStateSet[102X ([14Xfr: StateSet fr machine[114X) is a
  sphere    group.    DeclareProperty("IsSphereMachine",    IsGroupFRMachine);
  InstallImmediateMethod(IsSphereMachine,IsFRMachine,0, function(m) local g; g
  := StateSet(m); return HasIsSphereGroup(g) and IsSphereGroup(g); end);[133X
  
  [1X3.2-1 IsSphereMachine[101X
  
  [33X[1;0Y[29X[2XIsSphereMachine[102X( [3Xm[103X ) [32X filter[133X
  [33X[1;0Y[29X[2XIsPolynomialSphereMachine[102X( [3Xm[103X ) [32X filter[133X
  
  [33X[0;0YThe  categories of [13XSphere[113X and [13Xpolynomial[113X machines. Sphere machines are group
  FR  machines  whose  underlying  group  is  a  sphere group, see [2XSphereGroup[102X
  ([14X3.1-8[114X).[133X
  
  [33X[0;0YA polynomial machine is a group FR machine with a distinguished state (which
  must  be a generator of the stateset), stored as the attribute [2XAddingElement[102X
  ([14X3.3-7[114X);  see [2XAsPolynomialSphereMachine[102X ([14X3.3-8[114X). If it is normalized, in the
  sense   that   the   wreath   recursion   of   the   adding   element  [10Xa[110X  is
  [10X[[a,1,...,1],[d,1,...,d-1]][110X,  then the basepoint is assumed to be at [22X+âˆž[122X; the
  element  [10Xa[110X  describes  a clockwise loop around infinity; the [22Xk[122Xth preimage of
  the  basepoint is at [22Xexp(2iÏ€(k-1)/d)âˆž[122X, for [22Xk=1,dots,d[122X; and there is a direct
  connection from basepoint [22Xk[122X to [22Xk+1[122X for all [22Xk=1,dots,d-1[122X.[133X
  
  [33X[0;0YThe last category is the intersection of the first two.[133X
  
  [33X[0;0YDeclareAttribute("AsSphereMachine",                       IsGroupFRMachine);
  DeclareOperation("AsSphereMachine",       [IsGroupFRMachine,       IsWord]);
  DeclareOperation("AsSphereMachine", [IsGroupFRMachine, IsSphereGroup]);[133X
  
  [1X3.2-2 AsSphereMachine[101X
  
  [33X[1;0Y[29X[2XAsSphereMachine[102X( [3Xm[103X[, [3Xw[103X] ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YA sphere machine.[133X
  
  [33X[0;0YThis function creates a new sphere machine, starting from a group FR machine
  [3Xm[103X. If a state [3Xw[103X is specified, and that state defines the trivial FR element,
  then  it  is used as relator; if [3Xw[103X is a sphere group, then it is used as the
  new  stateset.  Finally,  if  no  relator and no group is specified, and the
  product  (in  some ordering) of the generators is trivial, then that product
  is used as relator. In other cases, the method returns [9Xfail[109X.[133X
  
  [33X[0;0YA   standard   FR  machine  can  be  recovered  from  a  sphere  machine  by
  [2XAsGroupFRMachine[102X     ([14Xfr:    AsGroupFRMachine[114X),    [2XAsMonoidFRMachine[102X    ([14Xfr:
  AsMonoidFRMachine[114X), and [2XAsSemigroupFRMachine[102X ([14Xfr: AsSemigroupFRMachine[114X).[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xm := UnderlyingFRMachine(BasilicaGroup);[127X[104X
    [4X[28X<Mealy machine on alphabet [ 1 .. 2 ] with 3 states>[128X[104X
    [4X[25Xgap>[125X [27Xg := AsGroupFRMachine(m);[127X[104X
    [4X[28X<FR machine with alphabet [ 1 .. 2 ] on Group( [ f1, f2 ] )>[128X[104X
    [4X[25Xgap>[125X [27XAsSphereMachine(g,Product(GeneratorsOfFRMachine(g)));[127X[104X
    [4X[28X<FR machine with alphabet [ 1 .. 2 ] on Group( [ f1, f2, t ] )/[ f1*f2*t ]>[128X[104X
    [4X[25Xgap>[125X [27XDisplay(last);[127X[104X
    [4X[28X G  |              1         2[128X[104X
    [4X[28X----+-----------------+---------+[128X[104X
    [4X[28X f1 |          <id>,2      f2,1[128X[104X
    [4X[28X f2 |          <id>,1      f1,2[128X[104X
    [4X[28X  t | f2^-1*f1*f2*t,2   f1^-1,1[128X[104X
    [4X[28X----+-----------------+---------+[128X[104X
    [4X[28XRelator: f1*f2*t[128X[104X
  [4X[32X[104X
  
  [33X[0;0YDeclareGlobalFunction("NewSphereMachine");[133X
  
  [1X3.2-3 NewSphereMachine[101X
  
  [33X[1;0Y[29X[2XNewSphereMachine[102X( [3X...[103X ) [32X attribute[133X
  [6XReturns:[106X  [33X[0;10YA new sphere machine, based on string descriptions.[133X
  
  [33X[0;0YThis command constructs a new sphere machine, in a format similar to [2XFRGroup[102X
  ([14Xfr:   FRGroup[114X);   namely,   the   arguments   are   strings   of  the  form
  "gen=<word-1,...,word-d>perm";  each [10Xword-i[110X is a word in the generators; and
  [10Xperm[110X  is  a  transformation,  either  written in disjoint cycle or in images
  notation. The underlying group of the machine is a sphere group.[133X
  
  [33X[0;0Y[10Xword-i[110X  is  allowed  to  be the empty string; and the "<...>" may be skipped
  altogether. Each [10Xword-i[110X may also contain inverses.[133X
  
  [33X[0;0YThe extra final arguments describe relations in the underlying sphere group;
  at  least  one  relation  is  required,  the product of the generators in an
  appropriate order.[133X
  
  [33X[0;0YThe  following  examples  construct  realizable  foldings  of the polynomial
  [22Xz^3+i[122X, following Cui's arguments.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xfold1 := NewSphereMachine("a=<,,b,,,B>(1,2,3)(4,5,6)","b=<,,b*a/b,,,B*A/B>",[127X[104X
    [4X[28X     "A=<,,b*a,,,B*A>(3,6)","B=(1,6,5,4,3,2)","a*B*A*b");[128X[104X
    [4X[25Xgap>[125X [27X<FR machine with alphabet [ 1, 2, 3, 4, 5, 6 ] on Group( [ a, b, A, B ] )/[ a*B*A*b ]>                                [127X[104X
    [4X[25Xgap>[125X [27Xfold2 := NewSphereMachine("a=<,,b,,,B>(1,2,3)(4,5,6)","b=<,,b*a/b,,,B*A/B>",[127X[104X
    [4X[28X     "A=(1,6)(2,5)(3,4)","B=<B*A,,,b*a,,>(1,4)(2,6)(3,5)","a*B*A*b");;[128X[104X
    [4X[25Xgap>[125X [27XP1MapBySphereMachine(fold1); P1MapBySphereMachine(fold2);[127X[104X
    [4X[28X...[128X[104X
  [4X[32X[104X
  
  
  [1X3.3 [33X[0;0YPolynomial sphere machines[133X[101X
  
  [33X[0;0YPolynomial  sphere machines have a special extra attribute, an [2XAddingElement[102X
  ([14X3.3-7[114X).  This  is  an  element of the underlying FR group, which acts as an
  adding  element  on the machine's alphabet. It represents a fixed point of a
  Thurston   map  of  maximal  ramification;  typically,  the  point  [22Xâˆž[122X  of  a
  polynomial.
  DeclareOperation("PolynomialMealyMachine",[IsPosInt,IsList,IsList]);
  DeclareOperation("PolynomialMealyMachine",[IsPosInt,IsList]);
  DeclareOperation("PolynomialSphereMachine",[IsPosInt,IsList,IsList,IsRecord]);
  DeclareOperation("PolynomialSphereMachine",[IsPosInt,IsList,IsList]);
  DeclareOperation("PolynomialSphereMachine",[IsPosInt,IsList,IsRecord]);
  DeclareOperation("PolynomialSphereMachine",[IsPosInt,IsList]);[133X
  
  [1X3.3-1 PolynomialSphereMachine[101X
  
  [33X[1;0Y[29X[2XPolynomialSphereMachine[102X( [3Xd[103X, [3Xper[103X[, [3Xpre[103X][, [3Xoptions[103X] ) [32X operation[133X
  [33X[1;0Y[29X[2XPolynomialMealyMachine[102X( [3Xd[103X, [3Xper[103X[, [3Xpre[103X] ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YA sphere or Mealy machine.[133X
  
  [33X[0;0YThis function creates a sphere or Mealy machine that describes a topological
  polynomial.  The  polynomial  is  described  symbolically in the language of
  [13Xexternal  angles[113X.  For more details, see [DH84] and [DH85] (in the quadratic
  case), [BFH92] (in the preperiodic case), and [Poi] (in the general case).[133X
  
  [33X[0;0Y[3Xd[103X  is  the  degree  of  the  polynomial.  [3Xper[103X and [3Xpre[103X are lists of angles or
  preangles.  In  what follows, angles are rational numbers, considered modulo
  1.  Each entry in [3Xper[103X or [3Xpre[103X is either a rational (interpreted as an angle),
  or a list of angles [22X[a_1,...,a_i][122X such that [22Xda_1=...=da_i[122X. The angles in [3Xper[103X
  are  angles  landing at the root of a Fatou component, and the angles in [3Xpre[103X
  land on the Julia set.[133X
  
  [33X[0;0YNote  that,  for sphere machines, the last generator of the machine produced
  is  an  adding  machine,  representing  a loop going counterclockwise around
  infinity  (in  the compactification of [22XC[122X by a disk, this loop goes [13Xclockwise[113X
  around that disk).[133X
  
  [33X[0;0YIn  constructing  a  polynomial  sphere  machine,  one  may specify a record
  [3Xoptions[103X,  which  may  contain  the following fields: [10Xmealy[110X (boolean, default
  [9Xfalse[109X)  specifies  if  a  formal construction is required; [10Xadding[110X specifying
  that  the  adding  machine  should have the most compact representation; and
  [10Xorbispace[110X  (boolean,  default  [9Xfalse[109X)  asking  the constructed group to have
  orbispace points of minimal degree.[133X
  
  [33X[0;0YIn  a [13Xformal[113X recursion, distinct angles give distinct generators; while in a
  non-formal  recursion,  distinct angles, which land at the same point in the
  Julia  set,  give a single generator. The simplest example where this occurs
  is  angle  [22X5/12[122X in the quadratic family, in which angles [22X1/3[122X and [22X2/3[122X land at
  the same point -- see the example below.[133X
  
  [33X[0;0YThe   attribute   [10XCorrespondence(m)[110X   records  the  angles  landing  on  the
  generators: [10XCorrespondence(m)[i][110X is a list [10X[a,s][110X where [22Xa[122X is an angle landing
  on generator [10Xi[110X and [22Xs[122X is [9X"Julia"[109X or [9X"Fatou"[109X.[133X
  
  [33X[0;0YIf  only  one  list  of angles is supplied, then [5XIMG[105X guesses that all angles
  with denominator coprime to [3Xn[103X are Fatou, and all the others are Julia.[133X
  
  [33X[0;0YThe inverse operation, reconstructing the angles from the sphere machine, is
  [2XSupportingRays[102X ([14X3.3-2[114X).[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XPolynomialSphereMachine(2,[0],[]); # the adding machine[127X[104X
    [4X[28X<FR machine with alphabet [ 1 .. 2 ] on Group( [ f1, f2 ] )/[ f2*f1 ]>[128X[104X
    [4X[25Xgap>[125X [27XDisplay(last);[127X[104X
    [4X[28X G  |     1        2[128X[104X
    [4X[28X----+--------+--------+[128X[104X
    [4X[28X f1 | <id>,2     f1,1[128X[104X
    [4X[28X f2 |   f2,2   <id>,1[128X[104X
    [4X[28X----+--------+--------+[128X[104X
    [4X[28XRelator: f2*f1[128X[104X
    [4X[25Xgap>[125X [27XDisplay(PolynomialSphereMachine(2,[1/3],[])); # the Basilica[127X[104X
    [4X[28X G  |      1         2[128X[104X
    [4X[28X----+---------+---------+[128X[104X
    [4X[28X f1 | f1^-1,2   f2*f1,1[128X[104X
    [4X[28X f2 |    f1,1    <id>,2[128X[104X
    [4X[28X f3 |    f3,2    <id>,1[128X[104X
    [4X[28X----+---------+---------+[128X[104X
    [4X[28XRelator: f3*f2*f1[128X[104X
    [4X[25Xgap>[125X [27XDisplay(PolynomialSphereMachine(2,[],[1/6])); # z^2+I[127X[104X
    [4X[28X G  |            1         2[128X[104X
    [4X[28X----+---------------+---------+[128X[104X
    [4X[28X f1 | f1^-1*f2^-1,2   f2*f1,1[128X[104X
    [4X[28X f2 |          f1,1      f3,2[128X[104X
    [4X[28X f3 |          f2,1    <id>,2[128X[104X
    [4X[28X f4 |          f4,2    <id>,1[128X[104X
    [4X[28X----+---------------+---------+[128X[104X
    [4X[28XRelator: f4*f3*f2*f1[128X[104X
    [4X[25Xgap>[125X [27XPolynomialSphereMachine(2,[],[5/12]);[127X[104X
    [4X[28X<FR machine with alphabet [ 1, 2 ] and adder f4 on Group( [ f1, f2, f3, f4 ] )/[ f4*f3*f2*f1 ]>[128X[104X
    [4X[25Xgap>[125X [27XCorrespondence(last);[127X[104X
    [4X[28X[ [ [ 1/3, 2/3 ], "Julia" ], [ [ 5/12 ], "Julia" ], [ [ 5/6 ], "Julia" ] ][128X[104X
    [4X[25Xgap>[125X [27XPolynomialSphereMachine(2,[],[5/12],rec(formal:=true));[127X[104X
    [4X[28X<FR machine with alphabet [ 1, 2 ] and adder f5 on Group( [ f1, f2, f3, f4, f5 ] )/[ f5*f4*f3*f2*f1 ]>[128X[104X
    [4X[25Xgap>[125X [27XCorrespondence(last);[127X[104X
    [4X[28X[ [ 1/3, "Julia" ], [ 5/12, "Julia" ], [ 2/3, "Julia" ], [ 5/6, "Julia" ] ][128X[104X
  [4X[32X[104X
  
  [33X[0;0YThe following construct the examples in Poirier's paper:[133X
  
  [4X[32X[104X
    [4XPoirierExamples := function(arg)[104X
    [4X    if arg=[1] then[104X
    [4X        return PolynomialSphereMachine(2,[1/7],[]);[104X
    [4X    elif arg=[2] then[104X
    [4X        return PolynomialSphereMachine(2,[],[1/2]);[104X
    [4X    elif arg=[3,1] then[104X
    [4X        return PolynomialSphereMachine(2,[],[5/12]);[104X
    [4X    elif arg=[3,2] then[104X
    [4X        return PolynomialSphereMachine(2,[],[7/12]);[104X
    [4X    elif arg=[4,1] then[104X
    [4X        return PolynomialSphereMachine(3,[[3/4,1/12],[1/4,7/12]],[]);[104X
    [4X    elif arg=[4,2] then[104X
    [4X        return PolynomialSphereMachine(3,[[7/8,5/24],[5/8,7/24]],[]);[104X
    [4X    elif arg=[4,3] then[104X
    [4X        return PolynomialSphereMachine(3,[[1/8,19/24],[3/8,17/24]],[]);[104X
    [4X    elif arg=[5] then[104X
    [4X        return PolynomialSphereMachine(3,[[3/4,1/12],[3/8,17/24]],[]);[104X
    [4X    elif arg=[6,1] then[104X
    [4X        return PolynomialSphereMachine(4,[],[[1/4,3/4],[1/16,13/16],[5/16,9/16]]);[104X
    [4X    elif arg=[6,2] then[104X
    [4X        return PolynomialSphereMachine(4,[],[[1/4,3/4],[3/16,15/16],[7/16,11/16]]);[104X
    [4X    elif arg=[7] then[104X
    [4X        return PolynomialSphereMachine(5,[[0,4/5],[1/5,2/5,3/5]],[[1/5,4/5]]);[104X
    [4X    elif arg=[9,1] then[104X
    [4X        return PolynomialSphereMachine(3,[[0,1/3],[5/9,8/9]],[]);[104X
    [4X    elif arg=[9,2] then[104X
    [4X        return PolynomialSphereMachine(3,[[0,1/3]],[[5/9,8/9]]);[104X
    [4X    else[104X
    [4X        Error("Unknown Poirier example ",arg);[104X
    [4X    fi;[104X
    [4Xend;[104X
  [4X[32X[104X
  
  [33X[0;0YDeclareAttribute("SupportingRays",IsFRMachine);[133X
  
  [1X3.3-2 SupportingRays[101X
  
  [33X[1;0Y[29X[2XSupportingRays[102X( [3Xm[103X ) [32X attribute[133X
  [6XReturns:[106X  [33X[0;10YA [10X[degree,fatou,julia][110X description of [3Xm[103X.[133X
  
  [33X[0;0YThis  operation  is  the  inverse  of  [2XPolynomialSphereMachine[102X  ([14X3.3-1[114X):  it
  computes a choice of angles, describing landing rays on Fatou/Julia critical
  points.[133X
  
  [33X[0;0YIf  there  does  not  exist  a complex realization, namely if the machine is
  obstructed, then this command returns an obstruction, as a record. The field
  [9Xminimal[109X  is  set  to  false,  and  a  proper sub-machine is set as the field
  [9Xsubmachine[109X.  The  field  [9Xhomomorphism[109X  gives an embedding of the stateset of
  [9Xsubmachine[109X  into  the  original  machine,  and  [9Xrelation[109X  is the equivalence
  relation on the set of generators of [3Xm[103X that describes the pinching.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xr := PolynomialSphereMachine(2,[1/7],[]);[127X[104X
    [4X[28X<FR machine with alphabet [ 1, 2 ] and adder f4 on Group( [ f1, f2, f3, f4 ] )/[ f4*f3*f2*f1 ]>[128X[104X
    [4X[25Xgap>[125X [27XF := StateSet(r);; SetName(F,"F");[127X[104X
    [4X[25Xgap>[125X [27XSupportingRays(r);[127X[104X
    [4X[28X[ 2, [ [ 1/7, 9/14 ] ], [  ] ] # actually returns the angle 2/7[128X[104X
    [4X[25Xgap>[125X [27X# now CallFuncList(PolynomialSphereMachine,last) would return the machine r[127X[104X
    [4X[25Xgap>[125X [27Xtwist := GroupHomomorphismByImages(F,F,GeneratorsOfGroup(F),[F.1^(F.2*F.1),F.2^F.1,F.3,F.4])^-1;[127X[104X
    [4X[28X[ f1, f2, f3, f4 ] -> [ f1*f2*f1^-1, f2*f1*f2*f1^-1*f2^-1, f3, f4 ][128X[104X
    [4X[25Xgap>[125X [27XList([-5..5],i->2*SupportingRays(r*twist^i)[2][1][1]);[127X[104X
    [4X[28X[ 4/7, 5/7, 4/7, 4/7, 5/7, 2/7, 4/7, 4/7, 2/7, 4/7, 4/7 ][128X[104X
    [4X[25Xgap>[125X [27Xr := PolynomialSphereMachine(2,[],[1/6]);;[127X[104X
    [4X[25Xgap>[125X [27XF := StateSet(r);;[127X[104X
    [4X[25Xgap>[125X [27Xtwist := GroupHomomorphismByImages(F,F,GeneratorsOfGroup(F),[F.1,F.2^(F.3*F.2),F.3^F.2,F.4]);;[127X[104X
    [4X[25Xgap>[125X [27XSupportingRays(r);[127X[104X
    [4X[28X[ 2, [  ], [ [ 1/12, 7/12 ] ] ][128X[104X
    [4X[25Xgap>[125X [27XSupportingRays(r*twist);[127X[104X
    [4X[28X[ 2, [  ], [ [ 5/12, 11/12 ] ] ][128X[104X
    [4X[25Xgap>[125X [27XSupportingRays(r*twist^2);[127X[104X
    [4X[28Xrec([128X[104X
    [4X[28X  transformation := [ [ f1, f2^-1*f3^-1*f2^-1*f3^-1*f2*f3*f2*f3*f2, f2^-1*f3^-1*f2^-1*f3*f2*f3*f2,[128X[104X
    [4X[28X          f4 ] -> [ f1, f2, f3, f4 ],[128X[104X
    [4X[28X      [ f1^-1*f2^-1*f1^-1*f2^-1*f1*f2*f1*f2*f1, f1^-1*f2^-1*f1^-1*f2*f1*f2*f1, f3, f4 ] ->[128X[104X
    [4X[28X        [ f1, f2, f3, f4 ],[128X[104X
    [4X[28X      [ f1^-1*f2^-1*f3^-1*f2*f1*f2^-1*f3*f2*f1, f2, f2*f1^-1*f2^-1*f3*f2*f1*f2^-1, f4 ] ->[128X[104X
    [4X[28X        [ f1, f2, f3, f4 ], [ f1, f3*f2*f3^-1, f3, f4 ] -> [ f1, f2, f3, f4 ],[128X[104X
    [4X[28X      [ f1, f2, f2*f3*f2^-1, f4 ] -> [ f1, f2, f3, f4 ],[128X[104X
    [4X[28X      [ f1, f3*f2*f3^-1, f3, f4 ] -> [ f1, f2, f3, f4 ],[128X[104X
    [4X[28X      [ f1, f2, f2*f3*f2^-1, f4 ] -> [ f1, f2, f3, f4 ],[128X[104X
    [4X[28X      [ f1, f3*f2*f3^-1, f3, f4 ] -> [ f1, f2, f3, f4 ] ], machine := <FR machine with alphabet[128X[104X
    [4X[28X    [ 1, 2 ] and adder f4 on Group( [ f1, f2, f3, f4 ] )/[ f4*f3*f2*f1 ]>, minimal := false,[128X[104X
    [4X[28X  submachine := <FR machine with alphabet [ 1, 2 ] and adder f3 on Group( [ f1, f2, f3 ] )>,[128X[104X
    [4X[28X  homomorphism := [ f1, f2, f3 ] -> [ f1, f2*f3, f4 ],[128X[104X
    [4X[28X  relation := <equivalence relation on <object> >, niter := 8 )[128X[104X
  [4X[32X[104X
  
  [33X[0;0YDeclareAttribute("FRMachineWithNormalizedAdder",IsGroupFRMachine);
  DeclareOperation("FRMachineWithNormalizedAdder",[IsGroupFRMachine,IsAssocWord]);[133X
  
  [1X3.3-3 FRMachineWithNormalizedAdder[101X
  
  [33X[1;0Y[29X[2XFRMachineWithNormalizedAdder[102X( [3Xm[103X[, [3Xadder[103X] ) [32X attribute[133X
  [6XReturns:[106X  [33X[0;10YA sphere machine.[133X
  
  [33X[0;0YThis function returns a new FR machine, in which the adding element has been
  put  into a standard form [22Xt=[t,1,dots,1]s[122X, where [22Xs[122X is the long cycle [22Xiâ†¦ i-1[122X.
  If  the adding element [3Xadder[103X is not specified, then [3Xm[103X should be a polynomial
  sphere machine, and [3Xadder[103X is its [10XAddingElement[110X.[133X
  
  [33X[0;0YDeclareAttribute("SimplifiedSphereMachine",IsSphereMachine);[133X
  
  [1X3.3-4 SimplifiedSphereMachine[101X
  
  [33X[1;0Y[29X[2XSimplifiedSphereMachine[102X( [3Xm[103X ) [32X attribute[133X
  [6XReturns:[106X  [33X[0;10YA simpler sphere machine.[133X
  
  [33X[0;0YThis   function  returns  a  new  sphere  machine,  with  hopefully  simpler
  transitions. The simplified machine is obtained by applying automorphisms to
  the  stateset. The sequence of automorphisms (in increasing order) is stored
  as   a   correspondence;   namely,   if  [10Xn=SimplifiedSphereMachine(m)[110X,  then
  [10Xm^Product(Correspondence(n))=n[110X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xr := PolynomialSphereMachine(2,[1/7],[]);;[127X[104X
    [4X[25Xgap>[125X [27XF := StateSet(r);; SetName(F,"F");[127X[104X
    [4X[25Xgap>[125X [27Xtwist := GroupHomomorphismByImages(F,F,GeneratorsOfGroup(F),[F.1^(F.2*F.1),F.2^F.1,F.3,F.4]);;[127X[104X
    [4X[25Xgap>[125X [27Xm := r*twist;; Display(m);[127X[104X
    [4X[28X G  |                     1            2[128X[104X
    [4X[28X----+------------------------+------------+[128X[104X
    [4X[28X f1 |          f1^-1*f2^-1,2   f3*f2*f1,1[128X[104X
    [4X[28X f2 | f1^-1*f2^-1*f1*f2*f1,1       <id>,2[128X[104X
    [4X[28X f3 |          f1^-1*f2*f1,1       <id>,2[128X[104X
    [4X[28X f4 |                   f4,2       <id>,1[128X[104X
    [4X[28X----+------------------------+------------+[128X[104X
    [4X[28XAdding element: f4[128X[104X
    [4X[28XRelator: f4*f3*f2*f1[128X[104X
    [4X[25Xgap>[125X [27Xn := SimplifiedSphereMachine(m);[127X[104X
    [4X[28X<FR machine with alphabet [ 1, 2 ] and adder f4 on F>[128X[104X
    [4X[25Xgap>[125X [27XDisplay(n);[127X[104X
    [4X[28X G  |            1            2[128X[104X
    [4X[28X----+---------------+------------+[128X[104X
    [4X[28X f1 | f2^-1*f1^-1,2   f1*f2*f3,1[128X[104X
    [4X[28X f2 |        <id>,1         f1,2[128X[104X
    [4X[28X f3 |        <id>,1         f2,2[128X[104X
    [4X[28X f4 |          f4,2       <id>,1[128X[104X
    [4X[28X----+---------------+------------+[128X[104X
    [4X[28XAdding element: f4[128X[104X
    [4X[28XRelator: f4*f1*f2*f3[128X[104X
    [4X[25Xgap>[125X [27Xn = m^Product(Correspondence(n));[127X[104X
    [4X[28Xtrue[128X[104X
  [4X[32X[104X
  
  [33X[0;0YDeclareOperation("Mating",[IsPolynomialSphereMachine,IsPolynomialSphereMachine]);
  DeclareOperation("Mating",[IsPolynomialSphereMachine,IsPolynomialSphereMachine,IsBool]);
  DeclareAttribute("EquatorElement",IsSphereMachine);
  DeclareAttribute("EquatorTwist",IsSphereMachine);[133X
  
  [1X3.3-5 Mating[101X
  
  [33X[1;0Y[29X[2XMating[102X( [3Xm1[103X, [3Xm2[103X[, [3Xformal[103X] ) [32X operation[133X
  [33X[1;0Y[29X[2XEquatorElement[102X( [3Xm[103X ) [32X attribute[133X
  [33X[1;0Y[29X[2XEquatorTwist[102X( [3Xm[103X ) [32X attribute[133X
  [6XReturns:[106X  [33X[0;10YA sphere machine.[133X
  
  [33X[0;0YThis function "mates" two polynomial sphere machines.[133X
  
  [33X[0;0YThe  mating  is  defined  as  follows:  one removes a disc around the adding
  machine  in  [3Xm1[103X and [3Xm2[103X; one applies complex conjugation to [3Xm2[103X; and one glues
  the hollowed spheres along their boundary circle.[133X
  
  [33X[0;0YThe  optional  argument  [3Xformal[103X, which defaults to [9Xtrue[109X, specifies whether a
  [13Xformal[113X  mating  should be done; in a non-formal mating, generators of [3Xm1[103X and
  [3Xm2[103X  which  have  identical  angle should be treated as a single generator. A
  non-formal  mating is of course possible only if the machines are realizable
  -- see [2XSupportingRays[102X ([14X3.3-2[114X).[133X
  
  [33X[0;0YThe  attribute [10XCorrespondence[110X is a pair of homomorphisms, from the statesets
  of [3Xm1,m2[103X respectively to the stateset of the mating.[133X
  
  [33X[0;0YThe  attribute  [10XEquatorElement[110X  is  set,  and  records  the  original adding
  elements of [3Xm1,m2[103X, which have become the equator of the mating.[133X
  
  [33X[0;0YNote  that  there are [22Xd-1[122X different matings between polynomials of degree [22Xd[122X:
  each  has  [22Xd-1[122X fixed rays at angles [22X2Ï€ ik/(d-1)[122X. This command constructs the
  mating  in  which  rays  at angle [22X0[122X are matched to each other. To obtain the
  other matings, multiply the machine by a power of its [10XEquatorTwist[110X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27X# the Tan-Shishikura examples[127X[104X
    [4X[25Xgap>[125X [27XSetP1Points(PMCOMPLEX);[127X[104X
    [4X[25Xgap>[125X [27Xz := Indeterminate(@IMG.field);;[127X[104X
    [4X[25Xgap>[125X [27Xa := RootsFloat((z-1)*(3*z^2-2*z^3)+1);;[127X[104X
    [4X[25Xgap>[125X [27Xc := RootsFloat((z^2+1)^3*z^2+1);;[127X[104X
    [4X[25Xgap>[125X [27Xam := List(a,a->SphereMachine((a-1)*(3*P1z^2-2*P1z^3)+1));;[127X[104X
    [4X[25Xgap>[125X [27Xcm := List(c,c->SphereMachine(P1z^3+c));;[127X[104X
    [4X[25Xgap>[125X [27Xm := ListX(am,cm,Mating);;[127X[104X
    [4X[25Xgap>[125X [27X# m[1] is realizable[127X[104X
    [4X[25Xgap>[125X [27XP1MapBySphereMachine(m[1]);[127X[104X
    [4X[28X((1.66408+I*0.668485)*z^3+(-2.59772+I*0.627498)*z^2+(-1.80694-I*0.833718)*z[128X[104X
    [4X[28X  +(1.14397-I*1.38991))/((-1.52357-I*1.27895)*z^3+(2.95502+I*0.234926)*z^2[128X[104X
    [4X[28X  +(1.61715+I*1.50244)*z+1)[128X[104X
    [4X[25Xgap>[125X [27X# m[29] is obstructed, and has a Levy cycle[127X[104X
    [4X[25Xgap>[125X [27XP1MapBySphereMachine(m[29]);[127X[104X
    [4X[28Xrec([128X[104X
    [4X[28X  machine := <sphere machine with alphabet [ 1, 2, 3 ] on Group( [ f1, f2, f3, g1, g2,\[128X[104X
    [4X[28X g3 ] ) / [ f3*f2*f1*g3*g2*g1 ]>, matrix := [ [ 1, 1/2 ], [ 1, 0 ] ],[128X[104X
    [4X[28X  multicurve := [ (f1*f3*f2)^2*f1*g1^-1*(g3*g2*g1)^3*f2^-1*f3*f2^G,[128X[104X
    [4X[28X      f1^-1*f2^-1*(f3*f2*f1)^4*g2*(g3*g2*g1)^3^G ] )[128X[104X
    [4X[25Xgap>[125X [27Xbut the other mating of the same polynomials is not obstructed:[127X[104X
    [4X[25Xgap>[125X [27XP1MapBySphereMatrix(m[29]*EquatorTwist(m[29]));[127X[104X
    [4X[28X<((-1.4495156808145406+0.44648102591936722i_z)*z^3+[128X[104X
    [4X[28X(-1.1286550578708263-0.40162285610021786i_z)*z^2+[128X[104X
    [4X[28X(1.0326873942952213-0.11770300021984977i_z)*z+[128X[104X
    [4X[28X(1.0940864612174037+0.24650956710141259i_z))/[128X[104X
    [4X[28X((0.85917327990384307-0.8755042485587835i_z)*z^3+[128X[104X
    [4X[28X(0.9573881709899621-0.14875521653926685i_z)*z^2+[128X[104X
    [4X[28X(-0.68923589444039035+0.48120812618585479i_z)*z+1._z)>[128X[104X
    [4X[25Xgap>[125X [27X# m[14] is the original Tan Lei-Shishikura example[127X[104X
    [4X[25Xgap>[125X [27XThurstonAlgorithm(m[14]);[127X[104X
    [4X[28Xrec([128X[104X
    [4X[28X  machine := <sphere machine with alphabet [ 1, 2, 3 ] on Group( [ f1, f2, f3, g1, g2, g3 ] ) / [ f\[128X[104X
    [4X[28X3*f2*f1*g3*g2*g1 ]>, matrix := [ [ 1/2, 1 ], [ 1/2, 0 ] ],[128X[104X
    [4X[28X  multicurve := [ f1^-1*f3*f2*f1*f3*f2*f1*g1^-1*g3*g2*g1*g3*g2*g1^G,[128X[104X
    [4X[28X                  f1^-1*f2*f1*f3*f2*f1*f3*f2*f1*g2*g3*g2*g1*g3*g2*g1^G ] )[128X[104X
  [4X[32X[104X
  
  [33X[0;0YDeclareProperty("IsKneadingMachine",IsFRMachine);
  DeclareAttribute("PlanarEmbeddingOfKneadingMachine",IsFRMachine);
  DeclareAttribute("PlanarEmbeddingsOfKneadingMachine",IsFRMachine);
  DeclareSynonym("IsPlanarKneadingMachine",HasPlanarEmbeddingOfKneadingMachine);
  InstallTrueMethod(IsBoundedFRMachine,IsKneadingMachine);
  InstallTrueMethod(IsLevelTransitive,IsKneadingMachine);[133X
  
  [1X3.3-6 IsKneadingMachine[101X
  
  [33X[1;0Y[29X[2XIsKneadingMachine[102X( [3Xm[103X ) [32X property[133X
  [33X[1;0Y[29X[2XPlanarEmbeddingOfKneadingMachine[102X( [3Xm[103X ) [32X attribute[133X
  [33X[1;0Y[29X[2XIsPlanarKneadingMachine[102X( [3Xm[103X ) [32X property[133X
  [6XReturns:[106X  [33X[0;10YWhether [3Xm[103X is a (planar) kneading machine.[133X
  
  [33X[0;0YA  [13Xkneading  machine[113X  is  a  special kind of Mealy machine, used to describe
  postcritically finite complex polynomials. It is a machine such that its set
  of  permutations  is  "treelike"  (see  [Nek05,  Â§6.7])  and  such that each
  non-trivial state occurs exactly once among the outputs.[133X
  
  [33X[0;0YFurthermore,  this  set  of  permutations  is  [13Xtreelike[113X  if  there exists an
  ordering  of  the  states  that  their  product in that order [22Xt[122X is an adding
  machine; i.e. such that [22Xt[122X's activity is a full cycle, and the product of its
  states  along  that  cycle  is conjugate to [22Xt[122X. This element [22Xt[122X represents the
  CarathÃ©odory loop around infinity.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XM := BinaryKneadingMachine("0");[127X[104X
    [4X[28XBinaryKneadingMachine("0*")[128X[104X
    [4X[25Xgap>[125X [27XDisplay(M);[127X[104X
    [4X[28X   |  1     2[128X[104X
    [4X[28X---+-----+-----+[128X[104X
    [4X[28X a | c,2   b,1[128X[104X
    [4X[28X b | a,1   c,2[128X[104X
    [4X[28X c | c,1   c,2[128X[104X
    [4X[28X---+-----+-----+[128X[104X
    [4X[25Xgap>[125X [27XIsPlanarKneadingMachine(M);[127X[104X
    [4X[28Xtrue[128X[104X
    [4X[25Xgap>[125X [27XPlanarEmbeddingOfKneadingMachine(M);[127X[104X
    [4X[28X[ 1, 2 ][128X[104X
    [4X[25Xgap>[125X [27XIsPlanarKneadingMachine(GrigorchukMachine);[127X[104X
    [4X[28Xfalse[128X[104X
  [4X[32X[104X
  
  [33X[0;0YDeclareAttribute("AddingElement", IsSphereMachine);[133X
  
  [1X3.3-7 AddingElement[101X
  
  [33X[1;0Y[29X[2XAddingElement[102X( [3Xm[103X ) [32X attribute[133X
  [6XReturns:[106X  [33X[0;10YThe element generating the adding submachine.[133X
  
  [33X[0;0YThis  attribute  stores the product of generators that is an adding machine.
  In  essence,  it  records  an  ordering  of  the  generators  whose  product
  corresponds to the CarathÃ©odory loop around infinity.[133X
  
  [33X[0;0YThe  following  example  illustrates Wittner's shared mating of the airplane
  and the rabbit. In the machine [10Xm[110X, an airplane is represented by [10XGroup(a,b,c)[110X
  and  a rabbit is represented by [10XGroup(x,y,z)[110X; in the machine [10Xnewm[110X, it is the
  other way round.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xf := FreeGroup("a","b","c","x","y","z");;[127X[104X
    [4X[25Xgap>[125X [27XAssignGeneratorVariables(f);[127X[104X
    [4X[25Xgap>[125X [27Xm := AsSphereMachine(FRMachine(f,[[a^-1,b*a],[One(f),c],[a,One(f)],[z*y*x,[127X[104X
    [4X[28X       x^-1*y^-1],[One(f),x],[One(f),y]],[(1,2),(),(),(1,2),(),()]));;[128X[104X
    [4X[25Xgap>[125X [27XDisplay(m);[127X[104X
    [4X[28X G |      1             2   [128X[104X
    [4X[28X---+---------+-------------+[128X[104X
    [4X[28X a |  a^-1,2         b*a,1  [128X[104X
    [4X[28X b |  <id>,1           c,2  [128X[104X
    [4X[28X c |     a,1        <id>,2  [128X[104X
    [4X[28X x | z*y*x,2   x^-1*y^-1,1  [128X[104X
    [4X[28X y |  <id>,1           x,2  [128X[104X
    [4X[28X z |  <id>,1           y,2  [128X[104X
    [4X[28X---+---------+-------------+[128X[104X
    [4X[28XRelator: z*y*x*c*b*a[128X[104X
    [4X[25Xgap>[125X [27Xiso := GroupHomomorphismByImages(f,f,[a,b^(y^-1),c^(x^-1*y^-1*a^-1),x^(b*a*z*a^-1),y,z^(a^-1)],[a,b,c,x,y,z]);;[127X[104X
    [4X[25Xgap>[125X [27Xnewm := ChangeFRMachineBasis(m^iso,[a^-1*y^-1,y^-1*a^-1*c^-1]);;[127X[104X
    [4X[25Xgap>[125X [27XDisplay(newm);[127X[104X
    [4X[28X G |          1         2   [128X[104X
    [4X[28X---+-------------+---------+[128X[104X
    [4X[28X a | a^-1*c^-1,2   c*a*b,1  [128X[104X
    [4X[28X b |      <id>,1       c,2  [128X[104X
    [4X[28X c |         a,1    <id>,2  [128X[104X
    [4X[28X x |       z*x,2    x^-1,1  [128X[104X
    [4X[28X y |      <id>,1       x,2  [128X[104X
    [4X[28X z |         y,1    <id>,2  [128X[104X
    [4X[28X---+-------------+---------+[128X[104X
    [4X[28XRelator: c*a*b*y*z*x[128X[104X
  [4X[32X[104X
  
  [33X[0;0YDeclareSynonym("IsPolynomialSphereMachine",IsSphereMachine               and
  HasAddingElement);
  DeclareAttribute("AsPolynomialSphereMachine",IsFRMachine);
  DeclareOperation("AsPolynomialSphereMachine",[IsFRMachine,IsWord]);[133X
  
  [1X3.3-8 AsPolynomialSphereMachine[101X
  
  [33X[1;0Y[29X[2XAsPolynomialSphereMachine[102X( [3Xm[103X[, [3Xadder[103X[, [3Xrelator[103X]] ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YA polynomial sphere machine.[133X
  
  [33X[0;0YThe  first function creates a new polynomial sphere machine, starting from a
  group or Mealy machine. A [13Xpolynomial[113X machine is one that has a distinguished
  adding element, [2XAddingElement[102X ([14X3.3-7[114X).[133X
  
  [33X[0;0YIf   the   argument   is   a   Mealy   machine,   it  must  be  planar  (see
  [2XIsPlanarKneadingMachine[102X  ([14X3.3-6[114X)).  If  the argument is a group machine, its
  permutations  must  be  treelike,  and  its outputs must be such that, up to
  conjugation,  each  non-trivial  state  appears  exactly once as the product
  along all cycles of all states.[133X
  
  [33X[0;0YIf a second argument [3Xadder[103X is supplied, it is checked to represent an adding
  element, and is used as such.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XM := PolynomialMealyMachine(2,[1/7],[]);[127X[104X
    [4X[28X<Mealy machine on alphabet [ 1 .. 2 ] with 4 states>[128X[104X
    [4X[25Xgap>[125X [27XMi := AsPolynomialSphereMachine(M);[127X[104X
    [4X[28X# (example still broken, have to fix spider algorithm)[128X[104X
  [4X[32X[104X
  
  [33X[0;0YDeclareOperation("LiftOfConjugacyClass",
  [IsGroupFRMachine,IsConjugacyClassGroupRep]);[133X
  
  [1X3.3-9 LiftOfConjugacyClass[101X
  
  [33X[1;0Y[29X[2XLiftOfConjugacyClass[102X( [3Xm[103X, [3Xc[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YA list of conjugacy classes and multiplicities.[133X
  
  [33X[0;0YThis  command  computes  the preimage of the conjugacy class [3Xc[103X by the sphere
  machine  [3Xm[103X, namely, it applies the wreath recursion to a representative of [3Xc[103X
  and  collects  the  products  on all cycles. It returns then a list of pairs
  [10X[cc,len][110X where [10Xcc[110X is the conjugacy class of a product on a cycle, and [10Xlen[110X is
  the length of the cycle.[133X
  
  [33X[0;0YDeclareAttribute("ComplexConjugate",  IsFRMachine);  #  already declared for
  arithmetic objects[133X
  
  [1X3.3-10 ComplexConjugate[101X
  
  [33X[1;0Y[29X[2XComplexConjugate[102X( [3Xm[103X ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YAn FR machine with inverted states.[133X
  
  [33X[0;0YThis  function  constructs  an  FR  machine  whose generating states are the
  inverses of the original states. If [3Xm[103X came from a complex rational map [22Xf(z)[122X,
  this would construct the machine of the conjugate map [22Xoverlinef(overline z)[122X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xa := PolynomialSphereMachine(2,[1/7]);[127X[104X
    [4X[28X<FR machine with alphabet [ 1, 2 ] and adder FRElement(...,f4) on <object>/[ f4*f3*f2*f1 ]>[128X[104X
    [4X[25Xgap>[125X [27XDisplay(a);[127X[104X
    [4X[28X G  |            1            2[128X[104X
    [4X[28X----+---------------+------------+[128X[104X
    [4X[28X f1 | f1^-1*f2^-1,2   f3*f2*f1,1[128X[104X
    [4X[28X f2 |          f1,1       <id>,2[128X[104X
    [4X[28X f3 |          f2,1       <id>,2[128X[104X
    [4X[28X f4 |          f4,2       <id>,1[128X[104X
    [4X[28X----+---------------+------------+[128X[104X
    [4X[28XAdding element: FRElement(...,f4)[128X[104X
    [4X[28XRelator: f4*f3*f2*f1[128X[104X
    [4X[25Xgap>[125X [27XDisplay(ComplexConjugate(a));[127X[104X
    [4X[28X G  |            1                     2[128X[104X
    [4X[28X----+---------------+---------------------+[128X[104X
    [4X[28X f1 | f1*f2*f3*f4,2   f4^-1*f2^-1*f1^-1,1[128X[104X
    [4X[28X f2 |          f1,1      <identity ...>,2[128X[104X
    [4X[28X f3 |          f2,1      <identity ...>,2[128X[104X
    [4X[28X f4 |          f4,2      <identity ...>,1[128X[104X
    [4X[28X----+---------------+---------------------+[128X[104X
    [4X[28XAdding element: FRElement(...,f4)[128X[104X
    [4X[28XRelator: f1*f2*f3*f4[128X[104X
    [4X[25Xgap>[125X [27XExternalAngle(a);[127X[104X
    [4X[28X{2/7}[128X[104X
    [4X[25Xgap>[125X [27XExternalAngle(ComplexConjugate(a));[127X[104X
    [4X[28X{6/7}[128X[104X
  [4X[32X[104X
  
  [33X[0;0YDeclareOperation("RotatedSpider",              [IsPolynomialSphereMachine]);
  DeclareOperation("RotatedSpider", [IsPolynomialSphereMachine, IsInt]);[133X
  
  [1X3.3-11 RotatedSpider[101X
  
  [33X[1;0Y[29X[2XRotatedSpider[102X( [3Xm[103X[, [3Xp[103X] ) [32X operation[133X
  [6XReturns:[106X  [33X[0;10YA polynomial FR machine with rotated spider at infinity.[133X
  
  [33X[0;0YThis  function  constructs  an  isomorphic polynomial FR machine, but with a
  different  numbering  of  the  spider  legs  at  infinity.  This rotation is
  accomplished by conjugating by [10Xadder^p[110X, where [10Xadder[110X is the adding element of
  [3Xm[103X, and [3Xp[103X, the rotation parameter, is [22X1[122X by default.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27Xa := PolynomialSphereMachine(3,[1/4]);[127X[104X
    [4X[28X<FR machine with alphabet [ 1, 2, 3 ] and adder FRElement(...,f3) on <object>/[ f3*f2*f1 ]>[128X[104X
    [4X[25Xgap>[125X [27XDisplay(a);[127X[104X
    [4X[28X G  |      1        2         3[128X[104X
    [4X[28X----+---------+--------+---------+[128X[104X
    [4X[28X f1 | f1^-1,2   <id>,3   f2*f1,1[128X[104X
    [4X[28X f2 |    f1,1   <id>,2    <id>,3[128X[104X
    [4X[28X f3 |    f3,3   <id>,1    <id>,2[128X[104X
    [4X[28X----+---------+--------+---------+[128X[104X
    [4X[28XAdding element: FRElement(...,f3)[128X[104X
    [4X[28XRelator: f3*f2*f1[128X[104X
    [4X[25Xgap>[125X [27XDisplay(RotatedSpider(a));[127X[104X
    [4X[28X G  |     1            2               3[128X[104X
    [4X[28X----+--------+------------+---------------+[128X[104X
    [4X[28X f1 | <id>,2   f2*f1*f3,3   f3^-1*f1^-1,1[128X[104X
    [4X[28X f2 | <id>,1       <id>,2   f3^-1*f1*f3,3[128X[104X
    [4X[28X f3 |   f3,3       <id>,1          <id>,2[128X[104X
    [4X[28X----+--------+------------+---------------+[128X[104X
    [4X[28XAdding element: FRElement(...,f3)[128X[104X
    [4X[28XRelator: f3*f2*f1[128X[104X
    [4X[25Xgap>[125X [27XExternalAngle(a);[127X[104X
    [4X[28X{3/8}[128X[104X
    [4X[25Xgap>[125X [27XList([1..10],i->ExternalAngle(RotatedSpider(a,i)));[127X[104X
    [4X[28X[ {7/8}, {1/4}, {7/8}, {1/4}, {7/8}, {1/4}, {7/8}, {1/4}, {7/8}, {1/4} ][128X[104X
  [4X[32X[104X
  
  [33X[0;0YDeclareAttribute("KneadingSequence", IsRat);[133X
  
  [1X3.3-12 KneadingSequence[101X
  
  [33X[1;0Y[29X[2XKneadingSequence[102X( [3Xangle[103X ) [32X attribute[133X
  [6XReturns:[106X  [33X[0;10YThe kneading sequence associated with [3Xangle[103X.[133X
  
  [33X[0;0YThis  function converts a rational angle to a kneading sequence, to describe
  a quadratic polynomial.[133X
  
  [33X[0;0YIf [3Xangle[103X is in [22X[1/7,2/7][122X and the option [10Xmarked[110X is set, the kneading sequence
  is decorated with markings in A,B,C.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XKneadingSequence(1/7);[127X[104X
    [4X[28X[ 1, 1 ][128X[104X
    [4X[25Xgap>[125X [27XKneadingSequence(1/5:marked);[127X[104X
    [4X[28X[ "A1", "B1", "B0" ][128X[104X
  [4X[32X[104X
  
  [33X[0;0YDeclareGlobalFunction("AllInternalAddresses");[133X
  
  [1X3.3-13 AllInternalAddresses[101X
  
  [33X[1;0Y[29X[2XAllInternalAddresses[102X( [3Xn[103X ) [32X attribute[133X
  [6XReturns:[106X  [33X[0;10YInternal addresses of maps with period up to [3Xn[103X.[133X
  
  [33X[0;0YThis  function  returns internal addresses for all periodic points of period
  up  to  [3Xn[103X  under  angle  doubling.  These  internal  addresses  describe the
  prominent hyperbolic components along the path from the landing point to the
  main  cardioid  in  the Mandelbrot set; this is a list of length [10X3k[110X, with at
  position  [10X3i+1,3i+2[110X the left and right angles, respectively, and at position
  [10X3i+3[110X the period of that component. For example, [10X[ 3/7, 4/7, 3, 1/3, 2/3, 2 ][110X
  describes the airplane: a polynomial with landing angles [22X[3/7,4/7][122X of period
  [22X3[122X;  and  such  that  there is a polynomial with landing angles [22X[1/3,2/3][122X and
  period [22X2[122X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XAllInternalAddresses(3);[127X[104X
    [4X[28X[ [  ], [ [ 1/3, 2/3, 2 ] ], [128X[104X
    [4X[28X[ [ 1/7, 2/7, 3 ], [ 3/7, 4/7, 3, 1/3, 2/3, 2 ], [ 5/7, 6/7, 3 ] ] ][128X[104X
  [4X[32X[104X
  
  [33X[0;0YDeclareGlobalFunction("ExternalAnglesRelation");[133X
  
  [1X3.3-14 ExternalAnglesRelation[101X
  
  [33X[1;0Y[29X[2XExternalAnglesRelation[102X( [3Xdegree[103X, [3Xn[103X ) [32X function[133X
  [6XReturns:[106X  [33X[0;10YAn equivalence relation on the rationals.[133X
  
  [33X[0;0YThis  function returns the equivalence relation on [10XRationals[110X identifying all
  pairs of external angles that land at a common point of period up to [3Xn[103X under
  angle multiplication by by [3Xdegree[103X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XExternalAnglesRelation(2,3);[127X[104X
    [4X[28X<equivalence relation on Rationals >[128X[104X
    [4X[25Xgap>[125X [27XEquivalenceRelationPartition(last);[127X[104X
    [4X[28X[ [ 1/7, 2/7 ], [ 1/3, 2/3 ], [ 3/7, 4/7 ], [ 5/7, 6/7 ] ][128X[104X
  [4X[32X[104X
  
  [33X[0;0YDeclareGlobalFunction("ExternalAngle");[133X
  
  [1X3.3-15 ExternalAngle[101X
  
  [33X[1;0Y[29X[2XExternalAngle[102X( [3Xmachine[103X ) [32X function[133X
  [6XReturns:[106X  [33X[0;10YThe external angle identifying [3Xmachine[103X.[133X
  
  [33X[0;0YIn  case  [3Xmachine[103X  is  the  sphere machine of a unicritical polynomial, this
  function  computes  the  external  angle landing at the critical value. More
  precisely,  it  computes  the equivalence class of that external angle under
  [2XExternalAnglesRelation[102X ([14X3.3-14[114X).[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XExternalAngle(PolynomialSphereMachine(2,[1/7])); # the rabbit[127X[104X
    [4X[28X{2/7}[128X[104X
    [4X[25Xgap>[125X [27XElements(last);[127X[104X
    [4X[28X[ 1/7, 2/7 ][128X[104X
  [4X[32X[104X
  
  
  [1X3.4 [33X[0;0YAutomorphisms of sphere machines[133X[101X
  
  [33X[0;0YConsider  a  sphere  group  [22XG[122X and its automorphism group [22XA[122X. If [22XM[122X is a sphere
  machine  for the group [22XG[122X, then pre- and post-composition by automorphisms in
  [22XA[122X  gives  new  sphere machines. The set of such sphere machines is naturally
  described       by       a      machine      for      the      group      [22XA[122X.
  DeclareOperation("AutomorphismVirtualEndomorphism",[IsGroupHomomorphism]);
  DeclareOperation("AutomorphismSphereMachine",[IsSphereMachine]);[133X
  
  [1X3.4-1 AutomorphismVirtualEndomorphism[101X
  
  [33X[1;0Y[29X[2XAutomorphismVirtualEndomorphism[102X( [3Xv[103X ) [32X attribute[133X
  [33X[1;0Y[29X[2XAutomorphismSphereMachine[102X( [3Xm[103X ) [32X attribute[133X
  [6XReturns:[106X  [33X[0;10YA description of the pullback map on TeichmÃ¼ller space.[133X
  
  [33X[0;0YLet [3Xm[103X be a sphere machine, thought of as a biset for the fundamental group [22XG[122X
  of a punctured sphere. Let [22XM[122X denote the automorphism of the surface, seen as
  a  group  of  outer  automorphisms  of [22XG[122X that fixes the conjugacy classes of
  punctures.[133X
  
  [33X[0;0YChoose  an  alphabet letter [3Xa[103X, and consider the virtual endomorphism [22Xv:G_a->
  G[122X.  Let  [22XH[122X denote the subgroup of [22XM[122X that fixes all conjugacy classes of [22XG_a[122X.
  then   there  is  an  induced  virtual  endomorphism  [22XÎ±:H->  M[122X,  defined  by
  [22Xt^Î±=v^-1tv[122X.  This  is  the  homomorphism  computed by the first command. Its
  source and range are in fact groups of automorphisms of range of [3Xv[103X.[133X
  
  [33X[0;0YThe  second  command  constructs  an  FR machine associated with [3X\alpha[103X. Its
  stateset  is  a  free  group  generated  by  elementary  Dehn  twists of the
  generators of [3XG[103X.[133X
  
  [4X[32X  Example  [32X[104X
    [4X[25Xgap>[125X [27XSetP1Points(PMCOMPLEX);[127X[104X
    [4X[25Xgap>[125X [27Xz := Indeterminate(@IMG.field);;[127X[104X
    [4X[25Xgap>[125X [27X# a Sierpinski carpet map without multicurves[127X[104X
    [4X[25Xgap>[125X [27Xm := SphereMachine((z^2-z^-2)/2/COMPLEX_I);[127X[104X
    [4X[28X<FR machine with alphabet [ 1, 2, 3, 4 ] on Group( [ f1, f2, f3, f4 ] )/[ f3*f2*f1*f4 ]>[128X[104X
    [4X[25Xgap>[125X [27XAutomorphismSphereMachine(i);[127X[104X
    [4X[28X<FR machine with alphabet [ 1, 2 ] on Group( [ x1, x2, x3, x4, x5, x6 ] )>[128X[104X
    [4X[25Xgap>[125X [27XDisplay(last);[127X[104X
    [4X[28X G  |     1        2[128X[104X
    [4X[28X----+--------+--------+[128X[104X
    [4X[28X x1 | <id>,2   <id>,1  [128X[104X
    [4X[28X x2 | <id>,1   <id>,2  [128X[104X
    [4X[28X x3 | <id>,2   <id>,1  [128X[104X
    [4X[28X x4 | <id>,2   <id>,1  [128X[104X
    [4X[28X x5 | <id>,1   <id>,2  [128X[104X
    [4X[28X x6 | <id>,2   <id>,1  [128X[104X
    [4X[28X----+--------+--------+[128X[104X
    [4X[25Xgap>[125X [27X# the original rabbit problem[127X[104X
    [4X[25Xgap>[125X [27Xm := PolynomialSphereMachine(2,[1/7],[]);;[127X[104X
    [4X[25Xgap>[125X [27Xv := VirtualEndomorphism(m,1);;[127X[104X
    [4X[25Xgap>[125X [27Xa := AutomorphismVirtualEndomorphism(v);[127X[104X
    [4X[28XMappingByFunction( <group with 20 generators>, <group with 6 generators>, function( a ) ... end )[128X[104X
    [4X[25Xgap>[125X [27XSource(a).1;[127X[104X
    [4X[28X[ f1, f2, f3, f4 ] -> [ f3*f2*f1*f2^-1*f3^-1, f2, f3, f3*f2*f1^-1*f2^-1*f3^-1*f2^-1*f3^-1 ][128X[104X
    [4X[25Xgap>[125X [27XImage(a,last);[127X[104X
    [4X[28X[ f1, f2, f3, f4 ] -> [ f1, f2, f2*f1*f3*f1^-1*f2^-1, f3^-1*f1^-1*f2^-1 ][128X[104X
    [4X[25Xgap>[125X [27X# so last2*m is equivalent to m*last[127X[104X
  [4X[32X[104X
  
